<?xml version="1.0" encoding="utf-8"?>
<vulnerabilities xmlns="http://tempuri.org/XMLSchemaOptions.xsd">

<vuln_items>wasc_1</vuln_items>
<vuln_item_wasc_1>
	<alert>Недостаточная аутентификация </alert>
	<desc>Недостаточная проверка подлинности происходит, когда веб-сайт позволяет злоумышленнику получить доступ к конфиденциальному содержимому или функциональности без необходимости надлежащей проверки подлинности. Веб-инструменты администрирования являются хорошим примером веб-сайтов, предоставляющих доступ к конфиденциальным функциям. В зависимости от конкретного интернет-ресурса эти веб-приложения не должны быть доступны напрямую, не требуя от пользователя надлежащей проверки его личности.

Чтобы обойти настройку аутентификации, некоторые ресурсы защищены "скрытием" определенного местоположения и не связывают расположение в основной веб-сайт или другие общественные места. Однако, такой подход-не более чем "Безопасность Через Неизвестность". Важно понимать что несмотря на то что ресурс неизвестен злоумышленнику, он по-прежнему остается доступным непосредственно через определенный URL-адрес. Конкретный URL-адрес может быть обнаружен с помощью зондирования грубой силы для общих расположений файлов и каталогов (/admin для образец), Сообщений об ошибках, журналов ссылок или документации, таких как файлы справки. Эти ресурсы, независимо от того управляются ли они контентом или функциональностью, должны быть надлежащим образом защищены.</desc>
	<solution>Фаза: Архитектура и дизайн
Использовать систему проверки подлинности или библиотеки такие как средство проверки подлинности сообщество owasp ESAPI.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authentication</reference>
	<reference>http://cwe.mitre.org/data/definitions/287.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
</vuln_item_wasc_1>

<vuln_items>wasc_2</vuln_items>
<vuln_item_wasc_2>
	<alert>Недостаточная Авторизация</alert>
	<desc>Недостаточная авторизация приводит к тому что приложение не выполняет адекватные проверки авторизации чтобы убедиться что пользователь выполняет функцию или доступ к данным в соответствии с политикой безопасности. Процедуры авторизации должны обеспечивать выполнение допустимых действий пользователя службы или приложения. Когда пользователь проходит проверку подлинности на веб-сайте это не обязательно означает что пользователь должен иметь полный доступ ко всему содержимому и функциональности.

Недостаточная Авторизация Функции

Многие приложения предоставляют различные функциональные возможности различным пользователям. Новостной сайт позволяет пользователям просматривать новости но не публиковать их. Система учета будет иметь разные разрешения для сотрудника по расчетам с поставщиками и сотрудника по дебиторской задолженности. Недостаточная авторизация функций происходит когда приложение не запрещает пользователям получать доступ к функциям приложения в нарушение политики безопасности.

Очень наглядным примером является хак 2005 года процесса подачи заявок Гарвардской школы бизнеса. Сбой авторизации позволил пользователям просматривать свои собственные данные когда им не должен был быть разрешен доступ к этой части веб-сайта.
 
Недостаточная Авторизация Данных

Многие приложения предоставляют базовые идентификаторы данных в URL-адресе. Например при доступе к медицинской записи в системе может быть URL-адрес, такой как:

http://example.com/RecordView?id=12345

Если приложение не проверяет имеет ли удостоверенный идентификатор пользователя права на чтение, затем он может отображать данные пользователя которые пользователь не должен видеть.

Nsufficient данные для авторизации является более распространенным чем недостаточная функция авторизации, потому что программисты как правило имеют полное представление о функциональности приложения, но не всегда есть полное сопоставление всех данных к которым приложение будет иметь доступ. Программисты часто имеют жесткий контроль над механизмами авторизации функций, но полагаться на другие системы такие как базы данных для выполнения авторизации данных.</desc>
	<solution>Фазы: Архитектура и дизайн; Операция
Очень тщательно управляйте настройкой, управление, и обращение с привилегиями. Явное управление доверительными зонами в программном обеспечении.

Фаза: Архитектура и дизайн 
Обеспечить надлежащее разделение заложено в конструкцию системы и что обособление служит для возможности и для дальнейшего укрепления привилегия разделению функционала. Архитекторы и дизайнеры должны полагаться на принцип наименьших привилегий чтобы решить когда это целесообразно использовать и отказаться от системных привилегий.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authorization</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/285.html</reference>
</vuln_item_wasc_2>

<vuln_items>wasc_3</vuln_items>
<vuln_item_wasc_3>
	<alert>Целочисленное переполнение</alert>
	<desc>Целочисленное переполнение-это условие которое возникает 
когда результат арифметической операции, как умножение или добавление, превышает максимальный размер целочисленного типа используемого для его хранения. При переполнении целого числа, измеренное значение появится "обернутые вокруг” максимальное значение и снова запускается при минимальном значении, подобно часам которые представляют 13: 00, указывая на 1: 00.

Например, 8-разрядное целое число со знаком на большинстве распространенных компьютерных архитектур имеет максимальное значение 127 и минимальное -128. Если программист сохраняет значение 127 в такой переменной и добавляет к ней 1, результат должен быть 128. Однако, это значение превышает максимальное для этого целочисленного типа, таким образом интерпретируемое значение "обернется" и станет -128.</desc>
	<solution>Фаза: Требования
Убедитесь что все протоколы строго определены, таким образом, что все вне границ поведение может быть идентифицировано просто, и требуют точного соблюдения протокола.

Этап: Требования
Используйте язык который не допускает возникновения этой слабости или предоставляет конструкции которые делают эту слабость легче избежать.
Если можно, выберите язык или компилятор выполняющий автоматическую проверку границ.

Этап: Архитектура и дизайн
Используйте проверенную библиотеку или платформу которая не позволяет этому недостатку возникать или предоставляет конструкции которые делают эту слабость легче избежать.
Используйте библиотеки или платформы которые облегчают обработку чисел без непредвиденных последствий.
Примеры включают безопасный целое обработку пакетов, таких как SafeInt (C++) или IntegerLib (C или C++).

Фаза: Реализация
Выполните проверку ввода для любого числового ввода, гарантируя что он находится в пределах ожидаемого диапазона. Убедитесь что входные данные соответствуют минимальным и максимальным требованиям для ожидаемого диапазона.
По возможности используйте целые числа без знака. Это облегчает выполнение проверок правильности для переполнения целых чисел. Если необходимо использовать целые числа со знаком, убедитесь что проверка диапазона включает как минимальные так и максимальные значения.

Фаза: Implementation
Understand your programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Обратите пристальное внимание на несоответствия размера байта, точность, подписанные/неподписанные различия, усечение, преобразование и приведение типов, ''не-число'' проведенные расчеты, и как ваш язык обрабатывает номера которые слишком велики или слишком малы для его базового представления.
Также будьте осторожны чтобы учитывать 32-бит, 64-битовый, и другие отличия которые могут повлиять на числовое представление.

Фаза: Реализация
Внимательно изучите предупреждения и ликвидации возможных серьезных проблем, например несоответствие подписанных / неподписанных. Даже если слабость редко эксплуатируется, один сбой может привести к компрометации всей системы.</solution>
	<reference>http://projects.webappsec.org/Integer-Overflows</reference>
	<reference>http://cwe.mitre.org/data/definitions/190.html</reference>
</vuln_item_wasc_3>

<vuln_items>wasc_4</vuln_items>
<vuln_item_wasc_4>
	<alert>Недостаточная Защита Транспортного Слоя</alert>
	<desc>Недостаточная Защита Транспортного Слоя
Недостаточная защита транспортного уровня позволяет связи подвергаться ненадежным третьи-страны, предоставление вектора атаки для компрометации веб-приложения и/или кражи конфиденциальной информации. Веб-сайты обычно используют протокол защищенных Сокетов / Транспорт слой безопасности (SSL/TLS) для обеспечения шифрования на транспортном уровне. Однако, если веб-сайт не настроен на использование SSL/TLS и настроен на использование SSL/TLS должным образом, сайт может быть уязвим для перехвата и модификации.
 
Отсутствие шифрования транспортного уровня
Если транспортный уровень не зашифрован, ll связь между веб-сайтом и клиентом отправляется четкий-текст который оставляет его открытым для перехвата, инъекция и перенаправление (также известный как человек-в-тот-средний/aтака MITM). Злоумышленник может пассивно перехватить сообщение, предоставление им доступа к любым передаваемым конфиденциальным данным таким как имена пользователей и пароли. Злоумышленник также может активно внедрение/удаление содержимого из сообщения, разрешение злоумышленнику подделывать и пропускать информацию, вредоносных скриптов, или вызвать клиент для доступа к удаленному недоверенному содержимому. Злоумышленник также может перенаправить сообщение таким образом чтобы веб-сайт и клиент больше не общались друг с другом, но вместо этого неосознанно общаются с злоумышленником в контексте другой доверенной стороны.

Слабая Поддержка Шифра
Исторически, высокая криптография класса была ограничена от экспорта за пределы Соединенных Штатов. Поэтому, веб-сайты были настроены для поддержки слабых криптографических опций для тех клиентов которые были ограничены только использованием слабых шифров. Слабые шифры уязвимы для атак из-за относительной легкости их взлома; 
менее двух недель на обычном домашнем компьютере и несколько секунд с использованием выделенного оборудования.
Сегодняшний день, все современные браузеры и веб сайты используют гораздо более сильное шифрование, но некоторые веб сайты по прежнему настроены для поддержки устаревших слабых шифров. Поэтому, злоумышленник может заставить клиента перейти на более слабый шифр при подключении к веб сайту, позволяет злоумышленнику сломать слабое шифрование. По этой причине, сервер должен быть настроен чтобы только принимать сильные шифры и не предоставлять сервис любому клиенту который запрашивает использование более слабого шифра. Кроме того, некоторые веб сайты неправильно настроены для выбора более слабого шифра даже если клиент будет поддерживать гораздо более сильный. OWASP предлагает руководство по тестированию проблем SSL/TLS, включая слабую поддержку шифров и неверную конфигурацию, и есть и другие ресурсы и инструменты.</desc>
	<solution>Фаза: Требования
Четко укажите какие данные или ресурсы являются достаточно ценными чтобы их можно было защитить с помощью шифрования. Требовать чтобы любая передача или хранение этих данных/ресурсов использовали хорошо проверенные алгоритмы шифрования.

Фаза: Архитектура и дизайн
Использование моделирования угроз или других методов, предположим что ваши данные могут быть скомпрометированы через отдельную Уязвимость или слабость, и определить где шифрование будет наиболее эффективным. Убедитесь что данные которые по вашему мнению должны быть частными не подвергаются непреднамеренному воздействию с использованием таких слабых мест как небезопасные разрешения (CWE-732).

Фаза: Архитектура и дизайн
Убедитесь что шифрование правильно интегрировано в конструкцию системы, в том числе но не ограничиваясь:
      Шифрование необходимое для хранения или передачи личных данных пользователей системы
            Шифрование необходимое для защиты самой системы от несанкционированного раскрытия или взлома 
Определение отдельных потребностей и контекстов для шифрования:
      Один-путь (т. е. ключ должен быть только у пользователя или получателя). Это может быть достигнуто с помощью криптографии с открытым ключом или других методов в которых шифрующая сторона (т. е., программное обеспечение) не нужно иметь доступ к закрытому ключу.
      Двухсторонний (т. е. шифрование может быть автоматически выполнено от имени пользователя но ключ должен быть доступен чтобы открытый текст мог быть автоматически восстановлен этим пользователем). Это требует хранения закрытого ключа в формате который может быть восстановлен только пользователем (или возможно операционной системой) таким образом который не может быть восстановлен другими.

Фаза: Архитектура и дизайн
Не разрабатывайте собственные криптографические алгоритмы. Они вероятно будут подвергаться атакам которые хорошо понятны криптографам. Методы обратного проектирования являются зрелыми. Если ваш алгоритм может быть скомпрометирован если злоумышленники узнают как он работает то он особенно слаб.

Фаза: Архитектура и дизайн
Выберите хорошо проверенный алгоритм который в настоящее время считается сильным экспертами в этой области, и выберите хорошо протестированные реализации.
Например, правительственные системы США требуют сертификации FIPS 140-2.
Как со всеми криптографическими механизмами, исходный код должен быть доступен для анализа.
Периодически убедитесь что Вы не используете устаревшую криптографию. Некоторые старые алгоритмы, когда-то думал, что потребуется миллиард лет вычислительного времени, теперь может быть нарушена в дни или часы. Это включает MD4, MD5, SHA1, DES, и другие алгоритмы которые когда-то считались сильными.

Фаза: Архитектура и дизайн
Разделите вашу систему чтобы иметь "безопасные" области где границы доверия могут быть однозначно нарисованы. Не допускайте выхода конфиденциальных данных за пределы границ доверия и всегда будьте осторожны при взаимодействии с отсеком за пределами безопасной зоны.

Фазы: Реализация; Архитектура и дизайн
При использовании одобренных в отрасли методов, вы должны использовать их правильно. Не режьте углы пропуская ресурсоемкие шаги (CWE-325). Эти шаги часто необходимы для предотвращения общих нападений.

Фаза: Реализация
Использовать соглашения об именовании и сильный Тип чтобы сделать его легче обнаружить когда конфиденциальные данные используется. При создании структур объектов, объекты, или другие сложные объекты как можно больше разделяют конфиденциальные и не чувствительные данные.
Это облегчает обнаружение мест в коде где используются незашифрованные данные.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Transport-Layer-Protection</reference>
	<reference>http://cwe.mitre.org/data/definitions/311.html</reference>
</vuln_item_wasc_4>

<vuln_items>wasc_5</vuln_items>
<vuln_item_wasc_5>
	<alert>Удаленное Включение Файлов</alert>
	<desc>Удаленный файл включает (RFI) является метод атаки используемый для использования "динамического файла включают" механизмы в веб-приложениях. Когда веб-приложений используется для ввода данных (адрес, значение параметра и т. д.) и передать их в файл включают команды, веб-приложение может быть обманным путем включения удаленных файлов с вредоносным кодом.

Почти все платформы веб-приложений поддерживают включение файлов. Включение файлов в основном используется для упаковки общего кода в отдельные файлы на которые позже ссылаются основные модули приложений. Когда веб-приложение ссылается на включаемый файл код в этом файле может выполняться неявно или явно путем вызова определенных процедур. Если выбор модуля для загрузки основан на элементах из HTTP-запроса, веб-приложение может быть уязвимо для RFI.
Злоумышленник может использовать RFI для:
    * Запуск вредоносного кода на сервере: любой код в включенных вредоносных файлах будет запущен сервером. Если файл include не выполняется с помощью какой-либо оболочки, код в include файлах выполняется в контексте пользователя сервера. Это может привести к полной компрометации системы.
    * Выполнение вредоносного кода на клиентах: вредоносный код злоумышленника может управлять содержимым ответа отправленного клиенту. The attacker can embed malicious code in the response that will be run by the client (for example, JavaScript to steal the client session cookies).

PHP is particularly vulnerable to RFI attacks due to the extensive use of "file includes" in PHP programming and due to default server configurations that increase susceptibility to an RFI attack.</desc>
	<solution>Этап: архитектура и дизайн
Когда набор допустимых объектов, таких как имена файлов или URL-адресов, ограничен или известен, создайте сопоставление из набора фиксированных входных значений (например, числовых идентификаторов) с фактическими именами файлов или URL-адресами и отклоните все остальные входные данные. 
Например, ID 1 можно сопоставить с «inbox.txt», а идентификатор 2 - с «profile.txt».  Такие функции, как ESAPI AccessReferenceMap, предоставляют эту возможность. 

Фазы: архитектура и дизайн; Операция
Запустите свой код в «тюрьме» или подобной среде песочницы, которая устанавливает строгие границы между процессом и операционной системой.  Это может эффективно ограничить, к каким файлам можно получить доступ в конкретном каталоге или какие команды могут выполняться вашим программным обеспечением. 
Примеры уровня ОС включают chroot jail Unix, AppArmor и SELinux.  В общем, управляемый код может обеспечить некоторую защиту.  Например, java.io.FilePermission в Java SecurityManager позволяет вам указывать ограничения на файловые операции. 
Это может быть невыполнимым решением, и оно только ограничивает влияние на операционную систему; остальная часть вашего приложения все еще может быть скомпрометирована. 
Будьте осторожны, чтобы избежать CWE-243 и других уязвимостей, связанных с тюрьмами. 
Для PHP интерпретатор предлагает ограничения, такие как открытый или безопасный режим, которые могут затруднить выход злоумышленника из приложения.  Также рассмотрите Suhosin, защищенное расширение PHP, которое включает в себя различные параметры, отключающие некоторые из наиболее опасных функций PHP. 

Этап: реализация
Предположим, что весь ввод злонамерен.  Используйте стратегию проверки входных данных «принять заведомо исправные», т. е. Используйте разрешенный список допустимых входных данных, которые строго соответствуют спецификациям.  Отклоняйте любой ввод, который не строго соответствует спецификациям, или преобразуйте его во что-то, что соответствует.  Не полагайтесь исключительно на поиск вредоносных или искаженных входных данных (т. е. Не полагайтесь на список запрещенных).  Однако списки запрета могут быть полезны для обнаружения потенциальных атак или определения того, какие входные данные настолько искажены, что их следует сразу отклонить. 
При выполнении проверки ввода учитывайте все потенциально важные свойства, включая длину, тип ввода, полный диапазон допустимых значений, отсутствующие или дополнительные вводы, синтаксис, согласованность между связанными полями и соответствие бизнес-правилам.  В качестве примера логики бизнес-правила «лодка» может быть синтаксически допустимой, потому что она содержит только буквенно-цифровые символы, но недействительна, если вы ожидаете такие цвета, как «красный» или «синий». 
Для имен файлов используйте строгие списки разрешений, которые ограничивают используемый набор символов.  Если возможно, разрешите только один "." в имени файла, чтобы избежать таких слабых мест, как CWE-23, и исключить разделители каталогов, такие как «/», чтобы избежать CWE-36.  Используйте разрешенный список допустимых расширений файлов, который поможет избежать CWE-434. 

Фазы: архитектура и дизайн; Операция
По возможности храните файлы библиотеки, включаемые файлы и служебные файлы вне корня веб-документа.  В противном случае сохраните их в отдельном каталоге и используйте возможности управления доступом веб-сервера, чтобы злоумышленники не запрашивали их напрямую.  Одна из распространенных практик - определять фиксированную константу в каждой вызывающей программе, а затем проверять наличие константы в библиотеке / включаемом файле; если константа не существует, значит, файл был запрошен напрямую, и он может немедленно выйти. 
Это значительно снижает вероятность того, что злоумышленник сможет обойти любые механизмы защиты, которые есть в базовой программе, но не во включаемых файлах.  Это также уменьшит вашу поверхность атаки. 

Фазы: архитектура и дизайн; Реализация
Поймите все потенциальные области, в которых ненадежные входные данные могут попасть в ваше программное обеспечение: параметры или аргументы, файлы cookie, все, что считывается из сети, переменные среды, обратный поиск DNS, результаты запросов, заголовки запросов, компоненты URL, электронная почта, файлы, базы данных и любые внешние системы, которые предоставляют данные приложению.  Помните, что такие входные данные могут быть получены косвенно через вызовы API. 
Многие проблемы с включением файлов возникают из-за того, что программист предполагал, что определенные входные данные нельзя изменить, особенно для файлов cookie и компонентов URL. </solution>
	<reference>http://projects.webappsec.org/Remote-File-Inclusion</reference>
	<reference>http://cwe.mitre.org/data/definitions/98.html</reference>
</vuln_item_wasc_5>

<vuln_items>wasc_6</vuln_items>
<vuln_item_wasc_6>
	<alert>Формат Строки </alert>
	<desc>Атаки на форматную строку изменяют поток приложения, используя функции библиотеки форматирования строк для доступа к другому пространству памяти.  Уязвимости возникают, когда данные, предоставленные пользователем, используются непосредственно в качестве входной строки форматирования для определенных функций C / C ++ (например, fprintf, printf, sprintf, setproctitle, syslog, ...). 

Если злоумышленник передает строку формата, состоящую из символов преобразования printf (например, «% f», «% p», «% n» и т. д.) в качестве значения параметра в веб-приложение, он может: 
    * Выполнить произвольный код на сервере
    * Считывать значения из стека
    * Причина ошибок сегментации / сбоев программного обеспечения 


Атаки с форматной строкой связаны с другими атаками в Классификации угроз: переполнение буфера и целочисленное переполнение.  Все три основаны на их способности манипулировать памятью или ее интерпретацией таким образом, чтобы способствовать достижению цели злоумышленника. </desc>
	<solution>Фаза: Требования
Выберите язык, на котором нет этого недостатка. 

Этап: реализация
Убедитесь, что все функции форматирования строки передаются статической строкой, которой не может управлять пользователь, и что правильное количество аргументов также всегда отправляется этой функции.  По возможности используйте функции, которые не поддерживают оператор% n в строках формата. 
Сборка: обратите внимание на предупреждения компиляторов и компоновщиков, так как они могут предупредить вас о неправильном использовании. 
</solution>
	<reference>http://projects.webappsec.org/Format-String</reference>
	<reference>http://cwe.mitre.org/data/definitions/134.html</reference>
</vuln_item_wasc_6>

<vuln_items>wasc_7</vuln_items>
<vuln_item_wasc_7>
	<alert>Переполнение буфера</alert>
	<desc>Переполнение буфера - это ошибка, которая возникает, когда в блок памяти или буфер записывается больше данных, чем выделено для хранения буфера.  Использование переполнения буфера позволяет злоумышленнику изменять части адресного пространства целевого процесса.  Эта способность может использоваться для ряда целей, в том числе для следующих:
     * Контроль выполнения процесса
     * Сбой процесса
     * Изменить внутренние переменные

Цель атакующего почти всегда - контролировать выполнение целевого процесса.  Это достигается путем идентификации указателя функции в памяти, которая может быть изменена прямо или косвенно с помощью переполнения.  Когда такой указатель используется программой, чтобы направить выполнение программы через прыжок или вызвать инструкцию, будет использоваться местоположение инструкции предоставленной злоумышленником, тем самым позволяя злоумышленнику контролировать процесс.

Во многих случаях, указатель функции изменяется чтобы ссылаться на место где злоумышленник разместил собранные машинные инструкции. Эти инструкции обычно называются shellcode, со ссылкой на то что злоумышленники часто хотят создать среду командной строки, или shell, в контексте запущенного процесса.

Переполнения буфера чаще всего связаны с программным обеспечением написанным на языках программирования C и C++ из-за их широкого использования и способности выполнять прямые манипуляции с памятью с общими программными конструкциями. It should be emphasized, however, that buffer overflows can exist in any programming environment where direct memory manipulation is allowed, whether through flaws in the compiler, runtime libraries, or features of the language itself.
</desc>
	<solution>Этап: Требования
Используйте язык который не допускает возникновения этой слабости или предоставляет конструкции которые делают эту слабость легче избежать.
For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.

Этап: Архитектура и дизайн
Используйте проверенную библиотеку или платформу которая не позволяет этому недостатку возникать или предоставляет конструкции которые делают эту слабость легче избежать.
Examples include the Safe C String Library (SafeStr) by Messier and Viega, and the Strsafe.h library from Microsoft. These libraries provide safer versions of overflow-prone string-handling functions. This is not a complete solution, since many buffer overflows are not related to strings.

Этап: сборка и компиляция
Запустите или скомпилируйте свое программное обеспечение, используя функции или расширения, которые автоматически обеспечивают механизм защиты, уменьшающий или устраняющий переполнение буфера. 
Например, некоторые компиляторы и расширения предоставляют механизмы автоматического обнаружения переполнения буфера, встроенные в скомпилированный код.  Примеры включают флаг Microsoft Visual Studio / GS, флаг Fedora / Red Hat FORTIFY SOURCE GCC, StackGuard и ProPolice. 

Этап: реализация
При распределении памяти приложения и управлении ею следует придерживаться следующих правил:
       Дважды проверьте, что ваш буфер такой большой, как вы указали. 
      При использовании функций, которые принимают количество байтов для копирования, таких как strncpy (), имейте в виду, что если размер целевого буфера равен размеру исходного буфера, он не может завершать строку NULL. 
      Проверьте границы буфера, если вызываете эту функцию в цикле, и убедитесь, что вам не угрожает запись за пределы выделенного пространства. 
      При необходимости обрежьте все входные строки до разумной длины, прежде чем передавать их функциям копирования и конкатенации. 

Фаза: Операция
Используйте такую функцию, как рандомизация разметки адресного пространства (ASLR). 

Фаза: Операция

Используйте ЦП и операционную систему, которая предлагает защиту выполнения данных (NX) или ее эквивалент. 

Этап: реализация

Замените функции неограниченного копирования аналогичными функциями, которые поддерживают аргументы длины, например strcpy на strncpy.  Создайте их, если они недоступны. 
</solution>
	<reference>http://projects.webappsec.org/Buffer-Overflow</reference>
	<reference>http://cwe.mitre.org/data/definitions/119.html</reference>
</vuln_item_wasc_7>

<vuln_items>wasc_8</vuln_items>
<vuln_item_wasc_8>
	<alert>Межсайтовый скриптинг </alert>
	<desc>Межсайтовый скриптинг (XSS) - это метод атаки, который включает повторение кода, предоставленного злоумышленником, в экземпляр браузера пользователя.  Экземпляр браузера может быть стандартным клиентом веб-браузера или объектом браузера, встроенным в программный продукт, например браузер в WinAmp, программу чтения RSS или клиент электронной почты.  Сам код обычно написан на HTML / JavaScript, но может также распространяться на VBScript, ActiveX, Java, Flash или любую другую технологию, поддерживаемую браузером. 
Когда злоумышленник заставляет браузер пользователя выполнить свой код, этот код будет выполняться в контексте (или зоне) безопасности веб-сайта, на котором он размещен.  С этим уровнем привилегий код имеет возможность читать, изменять и передавать любые конфиденциальные данные, доступные браузеру.  У пользователя с межсайтовым скриптом может быть взломана его / ее учетная запись (кража файлов cookie), их браузер перенаправлен в другое место или, возможно, будет показан мошеннический контент, доставленный веб-сайтом, который он посещает.  Атаки с использованием межсайтовых сценариев по существу ставят под угрозу доверительные отношения между пользователем и веб-сайтом.  Приложения, использующие экземпляры объектов браузера, которые загружают контент из файловой системы, могут выполнять код в зоне локального компьютера, что позволяет компрометировать систему. 

Существует три типа атак межсайтового скриптинга: непостоянные, постоянные и основанные на DOM. 
Непостоянные атаки и атаки на основе DOM требуют, чтобы пользователь либо посетил специально созданную ссылку с вредоносным кодом, либо посетил вредоносную веб-страницу, содержащую веб-форму, которая при размещении на уязвимом сайте инициирует атаку.  Использование вредоносной формы часто происходит, когда уязвимый ресурс принимает только запросы HTTP POST.  В таком случае форма может быть отправлена автоматически без ведома жертвы (например, с помощью JavaScript).  При нажатии на вредоносную ссылку или отправке вредоносной формы полезная нагрузка XSS будет отражена эхом, будет интерпретирована браузером пользователя и выполнена.  Другой способ отправки почти произвольных запросов (GET и POST) - использование встроенного клиента, такого как Adobe Flash. 
Постоянные атаки происходят, когда вредоносный код отправляется на веб-сайт, где он хранится в течение определенного периода времени.  Примеры излюбленных целей злоумышленника часто включают сообщения на досках объявлений, сообщения веб-почты и программное обеспечение для веб-чата.  Ничего не подозревающий пользователь не обязан взаимодействовать с каким-либо дополнительным сайтом / ссылкой (например, сайтом злоумышленника или вредоносной ссылкой, отправленной по электронной почте), просто просмотрите веб-страницу, содержащую код. </desc>
	<solution>Этап: Архитектура и дизайн
Используйте проверенную библиотеку или платформу которая не позволяет этому недостатку возникать или предоставляет конструкции которые делают эту слабость легче избежать.
Примеры библиотек и фреймворков, которые упрощают создание правильно закодированного вывода, включают библиотеку Microsoft Anti-XSS, модуль кодирования OWASP ESAPI и Apache Wicket. 

Этапы: реализация; Архитектура и дизайн
Поймите контекст, в котором будут использоваться ваши данные, и ожидаемую кодировку.  Это особенно важно при передаче данных между различными компонентами или при генерации выходных данных, которые могут содержать несколько кодировок одновременно, например, веб-страницы или составные почтовые сообщения.  Изучите все ожидаемые протоколы связи и представления данных, чтобы определить необходимые стратегии кодирования. 
Для любых данных, которые будут выводиться на другую веб-страницу, особенно для любых данных, полученных от внешних входов, используйте соответствующую кодировку для всех не буквенно-цифровых символов. 
Обратитесь к шпаргалке по предотвращению XSS для получения дополнительных сведений о необходимых типах кодирования и экранирования. 

Этап: архитектура и дизайн
Для любых проверок безопасности, которые выполняются на стороне клиента, убедитесь, что эти проверки дублируются на стороне сервера, чтобы избежать CWE-602.  Злоумышленники могут обойти проверки на стороне клиента, изменив значения после того, как проверки были выполнены, или изменив клиента, чтобы полностью удалить проверки на стороне клиента.  Затем эти измененные значения будут отправлены на сервер. 

Если возможно, используйте структурированные механизмы, которые автоматически обеспечивают разделение данных и кода.  Эти механизмы могут обеспечивать соответствующее цитирование, кодирование и проверку автоматически, вместо того, чтобы полагаться на разработчика, предоставляющего эту возможность в каждой точке, где генерируются выходные данные. 

Этап: реализация
Для каждой создаваемой веб-страницы используйте и укажите кодировку символов, такую как ISO-8859-1 или UTF-8.  Если кодировка не указана, веб-браузер может выбрать другую кодировку, угадав, какая кодировка фактически используется веб-страницей.  Это может привести к тому, что веб-браузер будет рассматривать определенные последовательности как особые, открывая клиента для тонких XSS-атак.  Смотри CWE-116 для дополнительных мер, связанных с кодированием / экранированием. 

Чтобы предотвратить атаки XSS на файл cookie сеанса пользователя, установите для файла cookie сеанса значение HttpOnly.  В браузерах, поддерживающих функцию HttpOnly (например, в более поздних версиях Internet Explorer и Firefox), этот атрибут может предотвратить доступ к cookie сеанса пользователя для вредоносных клиентских скриптов, использующих document.cookie.  Это не полное решение, поскольку HttpOnly поддерживается не всеми браузерами.  Что еще более важно, XMLHTTPRequest и другие мощные браузерные технологии предоставляют доступ для чтения к заголовкам HTTP, включая заголовок Set-Cookie, в котором установлен флаг HttpOnly. 

Предположим, что весь ввод злонамерен.  Используйте стратегию проверки входных данных «принять заведомо исправные», т. е. Используйте разрешенный список допустимых входных данных, которые строго соответствуют спецификациям.  Отклоняйте любой ввод, который не строго соответствует спецификациям, или преобразуйте его во что-то, что соответствует.  Не полагайтесь исключительно на поиск вредоносных или искаженных входных данных (т. е. Не полагайтесь на список запрещенных).  Однако списки запрета могут быть полезны для обнаружения потенциальных атак или определения того, какие входные данные настолько искажены, что их следует сразу отклонить. 

При выполнении проверки ввода учитывайте все потенциально важные свойства, включая длину, тип ввода, полный диапазон допустимых значений, отсутствующие или дополнительные вводы, синтаксис, согласованность между связанными полями и соответствие бизнес-правилам.  В качестве примера логики бизнес-правила «лодка» может быть синтаксически допустимой, потому что она содержит только буквенно-цифровые символы, но недействительна, если вы ожидаете такие цвета, как «красный» или «синий». 

Убедитесь, что вы выполняете проверку ввода на четко определенных интерфейсах в приложении.  Это поможет защитить приложение, даже если компонент будет повторно использован или перемещен в другое место. 
	</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Scripting</reference>
	<reference>http://cwe.mitre.org/data/definitions/79.html</reference>
</vuln_item_wasc_8>

<vuln_items>wasc_9</vuln_items>
<vuln_item_wasc_9>
	<alert>Подделка межсайтовых запросов </alert>
	<desc>Подделка межсайтового запроса - это атака, которая включает в себя принуждение жертвы к отправке HTTP-запроса в целевой пункт назначения без ее ведома или намерения, чтобы выполнить действие в качестве жертвы.  Основная причина - функциональность приложения, использующая предсказуемые действия URL / формы повторяющимся образом.  Суть атаки заключается в том, что CSRF использует доверие, которое веб-сайт имеет к пользователю.  Напротив, межсайтовый скриптинг (XSS) использует доверие пользователя к веб-сайту.  Как и XSS, CSRF-атаки не обязательно являются межсайтовыми, но могут быть.  Подделка межсайтовых запросов также известна как CSRF, XSRF, атака в один клик, сессионная атака, сбитый с толку помощник и морской серфинг. 

CSRF-атаки эффективны в ряде ситуаций, в том числе:
     * У жертвы активный сеанс на целевом сайте. 
    * Жертва аутентифицируется через HTTP-аутентификацию на целевом сайте. 
    * Жертва находится в той же локальной сети, что и целевой сайт. 

CSRF в основном использовался для выполнения действия против целевого сайта с использованием привилегий жертвы, но недавно были обнаружены методы раскрытия информации путем получения доступа к ответу.  Риск раскрытия информации резко возрастает, когда целевой сайт уязвим для XSS, потому что XSS может использоваться в качестве платформы для CSRF, позволяя атаке действовать в рамках политики одного и того же происхождения. </desc>
	<solution>Этап: Архитектура и дизайн
Используйте проверенную библиотеку или платформу которая не позволяет этому недостатку возникать или предоставляет конструкции которые делают эту слабость легче избежать.
Например, используйте пакеты анти-CSRF, такие как OWASP CSRFGuard. 

Этап: реализация
Убедитесь, что в вашем приложении нет проблем с межсайтовыми сценариями, потому что большинство средств защиты CSRF можно обойти с помощью сценария, управляемого злоумышленником. 

Этап: архитектура и дизайн
Создайте уникальный одноразовый номер для каждой формы, поместите одноразовый номер в форму и проверьте одноразовый номер после получения формы.  Убедитесь, что одноразовый номер непредсказуем (CWE-330). 
Обратите внимание, что это можно обойти с помощью XSS. 

Определите особо опасные операции.  Когда пользователь выполняет опасную операцию, отправьте отдельный запрос подтверждения, чтобы убедиться, что пользователь намеревался выполнить эту операцию. 
Обратите внимание, что это можно обойти с помощью XSS. 

Используйте элемент управления ESAPI Session Management. 
Этот элемент управления включает компонент для CSRF. 

Не используйте метод GET для любого запроса, который вызывает изменение состояния. 

Этап: реализация
Проверьте заголовок HTTP Referer, чтобы узнать, исходит ли запрос от ожидаемой страницы.  Это может нарушить законную функциональность, поскольку пользователи или прокси-серверы могли отключить отправку Referer по соображениям конфиденциальности. </solution>
	<reference>http://projects.webappsec.org/Cross-Site-Request-Forgery</reference>
	<reference>http://cwe.mitre.org/data/definitions/352.html</reference>
</vuln_item_wasc_9>

<vuln_items>wasc_10</vuln_items>
<vuln_item_wasc_10>
	<alert>Отказ в обслуживании </alert>
	<desc>Отказ в обслуживании (DoS) - это метод атаки, цель которого - помешать веб-сайту обслуживать обычную активность пользователя.  DoS-атаки, которые обычно легко применяются на сетевом уровне, также возможны на уровне приложений.  Эти злонамеренные атаки могут быть успешными из-за нехватки критических ресурсов в системе, использования уязвимостей или злоупотребления функциональностью. 

Часто DoS-атаки будут пытаться использовать все доступные системные ресурсы веб-сайта, такие как: ЦП, память, дисковое пространство и т. д.  Когда какой-либо из этих критических ресурсов будет полностью использован, веб-сайт обычно будет недоступен. 

Поскольку современные среды веб-приложений включают в себя веб-сервер, сервер базы данных и сервер аутентификации, DoS на уровне приложения может быть нацелен на каждый из этих независимых компонентов.  В отличие от DoS на сетевом уровне, где требуется большое количество попыток подключения, DoS на уровне приложений представляет собой гораздо более простую задачу. </desc>
	<solution>Этап: архитектура и дизайн

Разработайте механизмы дросселирования в архитектуре системы.  Лучшая защита - это ограничить количество ресурсов, которые неавторизованный пользователь может использовать.  Надежная модель аутентификации и контроля доступа в первую очередь поможет предотвратить подобные атаки.  Приложение для входа в систему должно быть максимально защищено от DoS-атак.  Ограничение доступа к базе данных, возможно, путем кэширования наборов результатов, может помочь минимизировать затрачиваемые ресурсы.  Чтобы еще больше ограничить вероятность DoS-атаки, рассмотрите возможность отслеживания скорости запросов, полученных от пользователей, и блокировки запросов, которые превышают определенный порог скорости. 

Смягчение атак с истощением ресурсов требует, чтобы целевая система:
       распознает атаку и отказывает этому пользователю в дальнейшем доступе в течение определенного периода времени, или
       равномерно регулирует все запросы, чтобы усложнить потребление ресурсов быстрее, чем их можно будет снова освободить.  

Первое из этих решений само по себе является проблемой, поскольку может позволить злоумышленникам предотвратить использование системы конкретным действующим пользователем.  Если злоумышленник выдает себя за действительного пользователя, он может предотвратить доступ пользователя к рассматриваемому серверу. 

Второе решение просто сложно внедрить эффективно - и даже при правильном выполнении оно не дает полного решения.  Это просто заставляет атаку требовать больше ресурсов со стороны злоумышленника. 

Убедитесь, что протоколы имеют определенные ограничения масштаба. 

Этап: реализация
Убедитесь, что все сбои в распределении ресурсов переводят систему в безопасное состояние. </solution>
	<reference>http://projects.webappsec.org/Denial-of-Service</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_10>

<vuln_items>wasc_11a</vuln_items>
<vuln_item_wasc_11a>
	<alert>Грубая форсировка учетных данных для входа </alert>
	<desc>Атака полным перебором - это метод определения неизвестного значения с помощью автоматизированного процесса для проверки большого количества возможных значений.  Атака использует тот факт, что энтропия значений меньше, чем предполагалось.  Например, хотя 8-значный буквенно-цифровой пароль может иметь 2,8 триллиона возможных значений, многие люди будут выбирать свои пароли из гораздо меньшего подмножества, состоящего из общеупотребительных слов и терминов. 

Наиболее распространенный тип атаки методом перебора в веб-приложениях - это атака на учетные данные для входа.  Поскольку пользователям необходимо запоминать пароли, они часто выбирают простые для запоминания слова или фразы в качестве паролей, что делает полезными атаки методом перебора с использованием словаря.  Такую атаку с попыткой входа в систему с использованием большого списка слов и фраз в качестве потенциальных паролей часто называют «атакой по списку слов» или «атакой по словарю».  Испытываемые пароли могут также включать вариации слов, общих для паролей, например, сгенерированные заменой «o» на «0» и «i» на «1», а также личную информацию, включая имена членов семьи, даты рождения и номера телефонов. 
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11a>

<vuln_items>wasc_11b</vuln_items>
<vuln_item_wasc_11b>
	<alert>Идентификаторы сеанса перебора </alert>
	<desc>Атака полным перебором - это метод определения неизвестного значения с помощью автоматизированного процесса для проверки большого количества возможных значений.  Атака использует тот факт, что энтропия значений меньше, чем предполагалось.  Например, хотя 8-значный буквенно-цифровой пароль может иметь 2,8 триллиона возможных значений, многие люди будут выбирать свои пароли из гораздо меньшего подмножества, состоящего из общеупотребительных слов и терминов. 

Поскольку HTTP является протоколом без сохранения состояния, для поддержания состояния веб-приложениям необходимо гарантировать, что идентификатор сеанса отправляется браузером с каждым запросом.  Идентификатор сеанса обычно хранится в файле cookie HTTP или URL-адресе.  Используя атаку методом грубой силы, злоумышленник может угадать идентификатор сеанса другого пользователя.  Это может привести к тому, что злоумышленник выдаст себя за пользователя, получит личную информацию и выполнит действия от имени пользователя. 
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11b>

<vuln_items>wasc_11c</vuln_items>
<vuln_item_wasc_11c>
	<alert>Грубая форсировка каталогов и файлов </alert>
	<desc>Атака полным перебором - это метод определения неизвестного значения с помощью автоматизированного процесса для проверки большого количества возможных значений.  Атака использует тот факт, что энтропия значений меньше, чем предполагалось.  Например, хотя 8-значный буквенно-цифровой пароль может иметь 2,8 триллиона возможных значений, многие люди будут выбирать свои пароли из гораздо меньшего подмножества, состоящего из общеупотребительных слов и терминов. 

Когда файлы находятся в каталогах, которые обслуживаются веб-сервером, но нигде не связаны, для доступа к этим файлам необходимо знать их имя.  В некоторых случаях эти файлы были оставлены по ошибке: например, файл резервной копии, автоматически созданный при редактировании файла, или остатки от более старой версии веб-приложения.  В других случаях файлы намеренно не связываются как механизм «защиты от неизвестности», позволяющий получить к ним доступ только людям, знающим имена файлов. 

Атака методом грубой силы пытается найти несвязанный файл, пытаясь получить доступ к большому количеству файлов.  Список возможных имен файлов может быть взят из списка известных потенциальных файлов или на основе вариантов видимых файлов на веб-сайте.  Более подробную информацию о каталогах и файлах методом перебора можно найти в соответствующей уязвимости и предсказуемом расположении ресурсов. 
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11c>

<vuln_items>wasc_11d</vuln_items>
<vuln_item_wasc_11d>
	<alert>Грубое принуждение информации о кредитной карте </alert>
	<desc>Атака полным перебором - это метод определения неизвестного значения с помощью автоматизированного процесса для проверки большого количества возможных значений.  Атака использует тот факт, что энтропия значений меньше, чем предполагалось.  Например, хотя 8-значный буквенно-цифровой пароль может иметь 2,8 триллиона возможных значений, многие люди будут выбирать свои пароли из гораздо меньшего подмножества, состоящего из общеупотребительных слов и терминов. 

Для покупок в Интернете с использованием украденных кредитных карт обычно требуется информация в дополнение к номеру кредитной карты, чаще всего это CVV / SCS и / или срок действия.  У мошенника может быть номер украденной кредитной карты без дополнительной информации.  Например, CVV / CSC не отпечатывается на карте и не хранится на магнитной полосе, поэтому он не может быть получен механическими или магнитными устройствами считывания кредитных карт. 

Чтобы заполнить недостающую информацию, хакер может угадать недостающую информацию, используя технику грубой силы, перебирая все возможные значения. 
    * Для угадывания CVV / CSC требуется всего 1000 или 10000 попыток, так как номер состоит всего из 3 или 4 цифр, в зависимости от типа карты. 
    * Для угадывания срока годности требуется всего несколько десятков попыток. 
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11d>

<vuln_items>wasc_12</vuln_items>
<vuln_item_wasc_12>
	<alert>Подмена контента </alert>
	<desc>Подмена контента - это метод атаки, который позволяет злоумышленнику внедрить вредоносную полезную нагрузку, которая впоследствии будет искажена как законный контент веб-приложения. 
 
Подмена только текстового контента
Обычный подход к динамическому построению страниц включает передачу тела или его частей на страницу через значение строки запроса.  Этот подход распространен на страницах с ошибками или на сайтах, содержащих статьи или новости.  Содержимое, указанное в этом параметре, позже отражается на странице, чтобы предоставить содержимое для страницы. 
 
Подмена отраженного содержимого разметки
Некоторые веб-страницы обслуживаются с использованием динамически создаваемых источников содержимого HTML.  Например, исходное местоположение кадра  <frame src="http://foo.example/file.html"/>) может быть указано значением параметра URL.  (http://foo.example/page?frame_src=http://foo.example/file.html). Злоумышленник может заменить значение параметра frame_src на frame_src = http: //attacker.example/spoof.html.  В отличие от перенаправителей, когда результирующая веб-страница обслуживается, строка местоположения браузера явно остается под ожидаемым пользователем доменом (foo.example), но внешние данные (attacker.example) скрыты легитимным содержимым. 

Специально созданные ссылки могут быть отправлены пользователю по электронной почте, в мгновенных сообщениях, оставлены на досках объявлений или навязаны пользователям с помощью атаки межсайтового скриптинга.  Если злоумышленник заставляет пользователя посетить веб-страницу, обозначенную их вредоносным URL-адресом, пользователь будет полагать, что просматривает подлинный контент из одного места, а это не так.  Пользователи будут неявно доверять поддельному контенту, поскольку в строке местоположения браузера отображается http: //foo.example, тогда как на самом деле базовый HTML-фрейм ссылается на http: //attacker.example. 

Эта атака использует доверительные отношения, установленные между пользователем и веб-сайтом.  Этот метод использовался для создания поддельных веб-страниц, включая формы входа, искажения, ложные пресс-релизы и т. д.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Content-Spoofing</reference>
	<reference>TBA</reference>
</vuln_item_wasc_12>

<vuln_items>wasc_13</vuln_items>
<vuln_item_wasc_13>
	<alert>Утечка информации </alert>
	<desc>Утечка информации - это слабое место приложения, при котором приложение раскрывает конфиденциальные данные, такие как технические детали веб-приложения, среды или пользовательские данные.  Конфиденциальные данные могут быть использованы злоумышленником для эксплуатации целевого веб-приложения, его хостинговой сети или пользователей.  Поэтому утечку конфиденциальных данных следует по возможности ограничивать или предотвращать.  Утечка информации, в ее наиболее распространенной форме, является результатом одного или нескольких из следующих условий: неспособность вычистить комментарии HTML / Script, содержащие конфиденциальную информацию, неправильные конфигурации приложения или сервера или различия в ответах страниц для допустимых и недействительных данных. . 

Если не очистить комментарии HTML / Script перед отправкой в производственную среду, это может привести к утечке конфиденциальной, контекстной информации, такой как структура каталогов сервера, структура запросов SQL и внутренняя сетевая информация.  Часто разработчик оставляет комментарии в коде HTML и / или сценария, чтобы облегчить процесс отладки или интеграции на этапе подготовки к производству.  Хотя разрешить разработчикам включать встроенные комментарии в разрабатываемый ими контент нет никакого вреда, все эти комментарии следует удалить до публичного выпуска контента. 

Номера версий программного обеспечения и подробные сообщения об ошибках (например, номера версий ASP.NET) являются примерами неправильной конфигурации сервера.  Эта информация полезна для злоумышленника, поскольку предоставляет подробные сведения о структуре, языках или встроенных функциях, используемых веб-приложением.  Большинство конфигураций серверов по умолчанию предоставляют номера версий программного обеспечения и подробные сообщения об ошибках для целей отладки и устранения неполадок.  Можно внести изменения в конфигурацию, чтобы отключить эти функции, предотвращая отображение этой информации. 

Страницы, которые предоставляют разные ответы в зависимости от достоверности данных, также могут привести к утечке информации; особенно когда данные, которые считаются конфиденциальными, раскрываются в результате разработки веб-приложения.  Примеры конфиденциальных данных включают (но не ограничиваются ими): номера учетных записей, идентификаторы пользователей (номер водительской лицензии, номер паспорта, номера социального страхования и т. Д.) И информацию о пользователях (пароли, сеансы, адреса).  Утечка информации в этом контексте связана с раскрытием ключевых пользовательских данных, считающихся конфиденциальными или секретными, которые не должны быть открыты для всеобщего обозрения даже пользователю.  Номера кредитных карт и другая строго регулируемая информация являются яркими примерами пользовательских данных, которые необходимо дополнительно защитить от раскрытия или утечки даже при наличии надлежащего шифрования и контроля доступа. </desc>
	<solution>Разделите свою систему, чтобы иметь «безопасные» области, где можно однозначно провести границы доверия.  Не допускайте выхода конфиденциальных данных за пределы границ доверия и всегда будьте осторожны при взаимодействии с отсеком за пределами безопасной зоны.</solution>
	<reference>http://projects.webappsec.org/Information-Leakage</reference>
	<reference>http://cwe.mitre.org/data/definitions/200.html</reference>
</vuln_item_wasc_13>

<vuln_items>wasc_14</vuln_items>
<vuln_item_wasc_14>
	<alert>Неверная конфигурация сервера </alert>
	<desc>Атаки неверной конфигурации сервера используют слабые места конфигурации, обнаруженные на веб-серверах и серверах приложений.  Многие серверы поставляются с ненужными файлами по умолчанию и образцами, включая приложения, файлы конфигурации, сценарии и веб-страницы.  У них также могут быть включены ненужные службы, такие как функции управления контентом и удаленного администрирования.  Могут быть включены отладочные функции или административные функции могут быть доступны анонимным пользователям.  Эти функции могут предоставить хакеру возможность обойти методы аутентификации и получить доступ к конфиденциальной информации, возможно, с повышенными привилегиями. 

Серверы могут включать в себя общеизвестные учетные записи и пароли по умолчанию.  Неспособность полностью заблокировать или укрепить сервер может привести к неправильной настройке прав доступа к файлам и каталогам.  Неверно настроенные сертификаты SSL и параметры шифрования, использование сертификатов по умолчанию и неправильная реализация аутентификации с внешними системами могут поставить под угрозу конфиденциальность информации. 

Подробные и информативные сообщения об ошибках могут привести к утечке данных, а раскрытая информация может быть использована для формулирования следующего уровня атаки.  Неправильная конфигурация серверного программного обеспечения может допускать атаки индексации каталогов и обхода пути. </desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Server-Misconfiguration</reference>
	<reference/>
</vuln_item_wasc_14>

<vuln_items>wasc_15</vuln_items>
<vuln_item_wasc_15>
	<alert>Неверная конфигурация приложения </alert>
	<desc>Атаки из-за неправильной конфигурации приложений используют недостатки конфигурации, обнаруженные в веб-приложениях.  Многие приложения поставляются с ненужными и небезопасными функциями, такими как функции отладки и контроля качества, включенные по умолчанию.  Эти функции могут предоставить хакеру возможность обойти методы аутентификации и получить доступ к конфиденциальной информации, возможно, с повышенными привилегиями. 

Аналогичным образом, установки по умолчанию могут включать хорошо известные имена пользователей и пароли, жестко запрограммированные учетные записи бэкдора, специальные механизмы доступа и неправильные разрешения, установленные для файлов, доступных через веб-серверы.  Образцы по умолчанию могут быть доступны в производственных средах.  Файлы конфигурации на основе приложений, которые не заблокированы должным образом, могут отображать четкие текстовые строки подключения к базе данных, а параметры по умолчанию в файлах конфигурации могут быть заданы не с учетом требований безопасности.  Все эти неправильные конфигурации могут привести к несанкционированному доступу к конфиденциальной информации. </desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Application-Misconfiguration</reference>
	<reference/>
</vuln_item_wasc_15>

<vuln_items>wasc_16</vuln_items>
<vuln_item_wasc_16>
	<alert>Индексирование каталогов </alert>
	<desc>Автоматический список / индексирование каталогов - это функция веб-сервера, которая перечисляет все файлы в запрошенном каталоге, если обычный базовый файл (index.html / home.html / default.htm / default.asp / default.aspx / index.php) нет.  Когда пользователь запрашивает главную страницу веб-сайта, он обычно вводит URL-адрес, например: http://www.example.com/directory1/ - используя имя домена и исключая конкретный файл.  Веб-сервер обрабатывает этот запрос и ищет в корневом каталоге документов имя файла по умолчанию и отправляет эту страницу клиенту.  Если эта страница отсутствует, веб-сервер динамически выдаст список каталогов и отправит результат клиенту.  По сути, это эквивалентно выполнению команды «ls» (Unix) или «dir» (Windows) в этом каталоге и отображению результатов в форме HTML.  С точки зрения атаки и противодействия важно понимать, что непреднамеренное перечисление каталогов может быть возможным из-за уязвимостей программного обеспечения (обсуждаемых в разделе примеров ниже) в сочетании с конкретным веб-запросом. </desc>
	<solution>Рекомендации включают ограничение доступа к важным каталогам или файлам путем принятия требования о необходимости знать как для документа, так и для корня сервера, а также отключение таких функций, как автоматические списки каталогов, которые могут раскрывать личные файлы и предоставлять информацию, которая может быть использована злоумышленником при формулировании или проведение нападения. </solution>
	<reference>http://projects.webappsec.org/Directory-Indexing</reference>
	<reference>http://cwe.mitre.org/data/definitions/548.html</reference>
</vuln_item_wasc_16>

<vuln_items>wasc_17</vuln_items>
<vuln_item_wasc_17>
	<alert>Неправильные разрешения файловой системы </alert>
	<desc>Неправильные разрешения файловой системы представляют собой угрозу конфиденциальности, целостности и доступности веб-приложения.  Проблема возникает, когда для файлов, папок и символических ссылок установлены неправильные разрешения файловой системы.  Если установлены неправильные разрешения, злоумышленник может получить доступ к файлам или каталогам с ограниченным доступом и изменить или удалить их содержимое.  Например, если учетная запись анонимного пользователя имеет разрешение на запись в файл, злоумышленник может изменить содержимое файла, влияя на веб-приложение нежелательными способами.  Злоумышленник также может использовать неправильные символические ссылки для повышения своих привилегий и / или доступа к неавторизованным файлам; например, символическая ссылка, указывающая на каталог за пределами корневого веб-каталога. </desc>
	<solution>Очень тщательно управляйте настройкой, управлением и обработкой разрешений.  Явно управляйте зонами доверия в программном обеспечении. </solution>
	<reference>http://projects.webappsec.org/Improper-Filesystem-Permissions</reference>
	<reference>http://cwe.mitre.org/data/definitions/280.html</reference>
</vuln_item_wasc_17>

<vuln_items>wasc_18</vuln_items>
<vuln_item_wasc_18>
	<alert>Учетные данные и прогнозирование сеанса </alert>
	<desc>Прогнозирование учетных данных / сеансов - это метод взлома или выдачи себя за пользователя веб-сайта.  Выведение или угадывание уникального значения, которое идентифицирует конкретный сеанс или пользователя, выполняет атаку.  Последствия, также известные как перехват сеанса, могут позволить злоумышленникам отправлять запросы к веб-сайтам с привилегиями скомпрометированного пользователя. 

Многие веб-сайты предназначены для аутентификации и отслеживания пользователя при первом установлении связи.  Для этого пользователи должны подтвердить свою личность на веб-сайте, обычно путем предоставления комбинации имени пользователя и пароля (учетных данных).  Вместо того, чтобы передавать эти конфиденциальные учетные данные туда и обратно с каждой транзакцией, веб-сайты будут генерировать уникальный «идентификатор сеанса», чтобы идентифицировать сеанс пользователя как аутентифицированный.  Последующее общение между пользователем и веб-сайтом помечается идентификатором сеанса как «доказательство» аутентифицированного сеанса.  Если злоумышленник может предсказать или угадать идентификатор сеанса другого пользователя, возможна мошенническая деятельность. </desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Credential-and-Session-Prediction</reference>
	<reference/>
</vuln_item_wasc_18>

<vuln_items>wasc_19</vuln_items>
<vuln_item_wasc_19>
	<alert>SQL-инъекция</alert>
	<desc>SQL-инъекция - это метод атаки, используемый для использования приложений, которые создают операторы SQL из введенных пользователем данных.  В случае успеха злоумышленник может изменить логику операторов SQL, выполняемых для базы данных. 

Язык структурированных запросов (SQL) - это специализированный язык программирования для отправки запросов к базам данных.  Язык программирования SQL является одновременно стандартом ANSI и ISO, хотя многие продукты баз данных, поддерживающие SQL, делают это с помощью проприетарных расширений стандартного языка.  Приложения часто используют данные, предоставленные пользователем, для создания операторов SQL.  Если приложению не удается правильно построить операторы SQL, злоумышленник может изменить структуру оператора и выполнить незапланированные и потенциально враждебные команды.  Когда такие команды выполняются, они делают это в контексте пользователя, указанного приложением, выполняющим инструкцию.  Эта возможность позволяет злоумышленникам получить контроль над всеми ресурсами базы данных, доступными для этого пользователя, включая возможность выполнять команды в системе хостинга. </desc>
	<solution>Этап: Архитектура и дизайн
Используйте проверенную библиотеку или платформу которая не позволяет этому недостатку возникать или предоставляет конструкции которые делают эту слабость легче избежать.
Например, рассмотрите возможность использования уровней сохраняемости, таких как Hibernate или Enterprise Java Beans, которые при правильном использовании могут обеспечить значительную защиту от внедрения SQL. 

Если возможно, используйте структурированные механизмы, которые автоматически обеспечивают разделение данных и кода.  Эти механизмы могут обеспечивать соответствующее цитирование, кодирование и проверку автоматически, вместо того, чтобы полагаться на разработчика, предоставляющего эту возможность в каждой точке, где генерируются выходные данные. 

Обработка запросов SQL с помощью подготовленных операторов, параметризованных запросов или хранимых процедур.  Эти функции должны принимать параметры или переменные и поддерживать строгую типизацию.  Не создавайте и не выполняйте строки запроса в этих функциях динамически, используя «exec» или аналогичные функции, поскольку вы можете повторно ввести возможность внедрения SQL. 

Запустите свой код, используя самые низкие привилегии, необходимые для выполнения необходимых задач.  Если возможно, создайте изолированные учетные записи с ограниченными правами, которые используются только для одной задачи.  Таким образом, успешная атака не предоставит злоумышленнику немедленный доступ к остальному программному обеспечению или его среде.  Например, приложениям баз данных редко требуется запускать от имени администратора базы данных, особенно в повседневных операциях. 

В частности, следуйте принципу наименьших привилегий при создании учетных записей пользователей в базе данных SQL.  Пользователи базы данных должны иметь только минимальные привилегии, необходимые для использования их учетной записи.  Если требования системы указывают на то, что пользователь может читать и изменять свои собственные данные, ограничьте их права, чтобы они не могли читать / записывать чужие данные.  Используйте максимально строгие разрешения для всех объектов базы данных, например, только выполнение для хранимых процедур. 

Этап: реализация
Если вам необходимо использовать динамически генерируемые строки запроса или команды, несмотря на риск, правильно заключите аргументы в кавычки и избегайте любых специальных символов в этих аргументах.  Самый консервативный подход - экранировать или фильтровать все символы, которые не проходят чрезвычайно строгий список разрешений (например, все, что не является буквенно-цифровым или пробельным).  Если некоторые специальные символы все еще необходимы, например, пробел, заключите каждый аргумент в кавычки после этапа экранирования / фильтрации.  Будьте осторожны с инъекцией аргументов (CWE-88). 

Вместо создания собственной реализации такие функции могут быть доступны в базе данных или языке программирования.  Например, пакет Oracle DBMS ASSERT может проверять или обеспечивать соблюдение определенных свойств параметров, которые делают их менее уязвимыми для SQL-инъекций.  Для MySQL функция API mysql real escape string () доступна как в C, так и в PHP. 

Предположим, что весь ввод злонамерен.  Используйте стратегию проверки входных данных «принять заведомо исправные», т. е. Используйте разрешенный список допустимых входных данных, которые строго соответствуют спецификациям.  Отклоняйте любой ввод, который не строго соответствует спецификациям, или преобразуйте его во что-то, что соответствует.  Не полагайтесь исключительно на поиск вредоносных или искаженных входных данных (т. е. Не полагайтесь на список запрещенных).  Однако списки запрета могут быть полезны для обнаружения потенциальных атак или определения того, какие входные данные настолько искажены, что их следует сразу отклонить. 

При выполнении проверки ввода учитывайте все потенциально важные свойства, включая длину, тип ввода, полный диапазон допустимых значений, отсутствующие или дополнительные вводы, синтаксис, согласованность между связанными полями и соответствие бизнес-правилам.  В качестве примера логики бизнес-правила «лодка» может быть синтаксически допустимой, потому что она содержит только буквенно-цифровые символы, но недействительна, если вы ожидаете такие цвета, как «красный» или «синий». 

При построении строк запроса SQL используйте строгие списки разрешений, которые ограничивают набор символов на основе ожидаемого значения параметра в запросе.  Это косвенно ограничит масштаб атаки, но этот метод менее важен, чем правильное кодирование вывода и экранирование. 

Обратите внимание, что правильное кодирование вывода, экранирование и цитирование являются наиболее эффективным решением для предотвращения внедрения SQL, хотя проверка ввода может обеспечить некоторую глубинную защиту.  Это потому, что он эффективно ограничивает то, что будет отображаться на выходе.  Проверка ввода не всегда предотвращает внедрение SQL, особенно если вам необходимо поддерживать текстовые поля произвольной формы, которые могут содержать произвольные символы.  Например, имя «О'Рейли», скорее всего, пройдет этап проверки, поскольку это обычная фамилия на английском языке.  Однако его нельзя напрямую вставить в базу данных, потому что он содержит символ апострофа «'», который нужно было бы экранировать или обработать иным образом.  В этом случае удаление апострофа может снизить риск SQL-инъекции, но приведет к неправильному поведению, поскольку будет записано неправильное имя. 

По возможности, безопаснее всего полностью запретить метасимволы вместо их экранирования.  Это обеспечит некоторую глубокую защиту.  После ввода данных в базу данных более поздние процессы могут игнорировать экранирование метасимволов перед использованием, и вы можете не контролировать эти процессы. </solution>
	<reference>http://projects.webappsec.org/SQL-Injection</reference>
	<reference/>
</vuln_item_wasc_19>

<vuln_items>wasc_20</vuln_items>
<vuln_item_wasc_20>
	<alert>Неправильная обработка ввода </alert>
	<desc>Неправильная обработка ввода - одна из наиболее распространенных слабостей, выявленных сегодня во всех приложениях.  Плохо обрабатываемый ввод - основная причина критических уязвимостей, существующих в системах и приложениях. 
	
Как правило, термин «обработка ввода» используется для описания таких функций, как проверка, очистка, фильтрация, кодирование и / или декодирование входных данных.  Приложения получают входные данные из различных источников, включая пользователей, программные агенты (браузеры) и сетевые / периферийные устройства, и это лишь некоторые из них.  В случае веб-приложений ввод можно передавать в различных форматах (пары имя-значение, JSON, SOAP и т. Д.) И получать через строки запроса URL, данные POST, заголовки HTTP, файлы cookie и т. д.  Входные данные, не относящиеся к веб-приложению, могут быть получены через переменные приложения, переменные среды, реестр, файлы конфигурации и т. д.  Независимо от формата данных или источника / местоположения ввода, все вводимые данные следует считать ненадежными и потенциально вредоносными.  Приложения, обрабатывающие ненадежный ввод, могут стать уязвимыми для таких атак, как переполнение буфера, внедрение SQL, управление ОС, отказ в обслуживании и многие другие. 

Одним из ключевых аспектов обработки ввода является проверка того, что ввод удовлетворяет определенным критериям.  Для надлежащей проверки важно определить форму и тип данных, которые приемлемы и ожидаются приложением.  Для точного определения ограничений требуется определение ожидаемого формата и использования каждого экземпляра ненадежных входных данных.  

Проверка может включать проверки безопасности типов и правильного синтаксиса.  String input can be checked for length (min and max number of characters) and character set validation while numeric input types like integers and decimals can be validated against acceptable upper and lower bound of values. When combining input from multiple sources, validation should be performed during concatenation and not just against the individual data elements. This practice helps avoid situations where input validation may succeed when performed on individual data items but fails when done on a combined set from all the sources.</desc>
	<solution>Phase: Architecture and Design

Use an input validation framework such as Struts or the OWASP ESAPI Validation API.

Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Помните, что такие входные данные могут быть получены косвенно через вызовы API. 

For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side. Злоумышленники могут обойти проверки на стороне клиента, изменив значения после того, как проверки были выполнены, или изменив клиента, чтобы полностью удалить проверки на стороне клиента.  Затем эти измененные значения будут отправлены на сервер. 

Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.

Do not rely exclusively on deny list validation to detect malicious input or to encode output. There are too many ways to encode the same character, so you're likely to miss some variants.

When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.

Предположим, что весь ввод злонамерен.  Используйте стратегию проверки входных данных «принять заведомо исправные», т. е. Используйте разрешенный список допустимых входных данных, которые строго соответствуют спецификациям.  Отклоняйте любой ввод, который не строго соответствует спецификациям, или преобразуйте его во что-то, что соответствует.  Не полагайтесь исключительно на поиск вредоносных или искаженных входных данных (т. е. Не полагайтесь на список запрещенных).  Однако списки запрета могут быть полезны для обнаружения потенциальных атак или определения того, какие входные данные настолько искажены, что их следует сразу отклонить. 

При выполнении проверки ввода учитывайте все потенциально важные свойства, включая длину, тип ввода, полный диапазон допустимых значений, отсутствующие или дополнительные вводы, синтаксис, согласованность между связанными полями и соответствие бизнес-правилам.  В качестве примера логики бизнес-правила «лодка» может быть синтаксически допустимой, потому что она содержит только буквенно-цифровые символы, но недействительна, если вы ожидаете такие цвета, как «красный» или «синий». 

Phase: Implementation

Be especially careful to validate your input when you invoke code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.

Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not inadvertently decode the same input twice. Such errors could be used to bypass allow list schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.

Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.

When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.</solution>
	<reference>http://projects.webappsec.org/Improper-Input-Handling</reference>
	<reference>http://cwe.mitre.org/data/definitions/89.html</reference>
</vuln_item_wasc_20>

<vuln_items>wasc_21</vuln_items>
<vuln_item_wasc_21>
	<alert>Insufficient Anti automation</alert>
	<desc>Insufficient Anti-automation occurs when a web application permits an attacker to automate a process that was originally designed to be performed only in a manual fashion, i.e. by a human web user.

Web application functionality that is often a target for automation attacks may include:
    * Application login forms – attackers may automate brute force login requests in an attempt to guess user credentials
    * Service registration forms – attackers may automatically create thousands of new accounts
    * Email forms – attackers may exploit email forms as spam relays or for flooding a certain user’s mailbox
    * Account maintenance – attackers may perform mass DoS against an application, by flooding it with numerous requests to disable or delete user accounts
    * Account information forms – attackers may perform mass attempts to harvest user personal information from a web application
    * Comment forms / Content Submission forms – these may be used for spamming blogs, web forums and web bulletin boards by automatically submitting contents such as spam or even web-based malware
    * Forms tied to SQL database queries - these may be exploited in order to perform a denial of service attack against the application. The attack is performed by sending numerous heavy SQL queries in a short period of time, hence denying real users from service.
    * eShopping / eCommerce - eShopping and eCommerce applications that do not enforce human-only buyers, can be exploited in order to buy preferred items in large amounts, such as sporting events tickets. These are later sold by scalpers for higher prices.
    * Online polls - polls and other types of online voting systems can be automatically subverted in favor of a certain choice.
    * Web-based SMS message sending - attackers may exploit SMS message sending systems in order to spam mobile phone users
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient+Anti-automation</reference>
	<reference>http://cwe.mitre.org/data/definitions/116.html</reference>
</vuln_item_wasc_21>

<vuln_items>wasc_22</vuln_items>
<vuln_item_wasc_22>
	<alert>Improper Output Handling</alert>
	<desc>Output handling refers to how an application generates outgoing data.  If an application has improper output handling, the output data may be consumed leading to vulnerabilities and actions never intended by the application developer.  In many cases, this unintended interpretation is classified as one or more forms of critical application vulnerabilities.

Any location where data leaves an application boundary may be subject to improper output handling.  Application boundaries exist where data leaves one context and enters another.  This includes applications passing data to other applications via web services, sockets, command line, environmental variables, etc...  It also includes passing data between tiers within an application architecture, such as a database, directory server, HTML/JavaScript interpreter (browser), or operating system.  More detail on where improper output handling can occur can be found in the section below titled "Common Data Output Locations”.

Improper output handling may take various forms within an application.  These forms can be categorized into: protocol errors, application errors and data consumer related errors.  Protocol errors include missing or improper output encoding or escaping and outputting of invalid data.  Application errors include logic errors such as outputting incorrect data or passing on malicious content unfiltered.  If the application does not properly distinguish legitimate content from illegitimate, or does not work around known vulnerabilities in the data consumer, it may result in data-consumer abuse caused from improper output handling.

An application that does not provide data in the correct context may allow an attacker to abuse the data consumer.  This can lead to specific threats referenced within the WASC Threat Classification, including Content Spoofing, Cross-Site Scripting, HTTP Response Splitting, HTTP Response Smuggling, LDAP Injection, OS Commanding, Routing Detour, Soap Array Abuse, URL Redirector, XML Injection, XQuery Injection, XPath Injection, Mail Command Injection, Null Injection and SQL Injection.

Proper output handling prevents the unexpected or unintended interpretation of data by the consumer.  To achieve this objective, developers must understand the application's data model, how the data will be consumed by other portions of the application, and how it will ultimately be presented to the user.  Techniques for ensuring the proper handling of output include but are not limited to the filtering and sanitization of data (more detail on output sanitization and filtering can be found in appropriately titled sections below).  However, inconsistent use of selected output handling techniques may actually increase the risk of improper output handling if output data is overlooked or left untreated.  To ensure "defense in depth" developers must assume that all data within an application is untrusted when choosing appropriate output handling strategies.

While proper output handling may take many different forms, an application cannot be secure unless it protects against unintended interpretations by the data consumer. This core requirement is essential for an application to securely handle output operations.</desc>
	<solution>Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.

For example, consider using the ESAPI Encoding control or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.

Alternately, use built-in functions, but consider using wrappers in case those functions are discovered to have a vulnerability.

Если возможно, используйте структурированные механизмы, которые автоматически обеспечивают разделение данных и кода.  Эти механизмы могут обеспечивать соответствующее цитирование, кодирование и проверку автоматически, вместо того, чтобы полагаться на разработчика, предоставляющего эту возможность в каждой точке, где генерируются выходные данные. 

For example, stored procedures can enforce database query structure and reduce the likelihood of SQL injection.

Understand the context in which your data will be used and the encoding that will be expected. Это особенно важно при передаче данных между различными компонентами или при генерации выходных данных, которые могут содержать несколько кодировок одновременно, например, веб-страницы или составные почтовые сообщения.  Изучите все ожидаемые протоколы связи и представления данных, чтобы определить необходимые стратегии кодирования. 

In some cases, input validation may be an important strategy when output encoding is not a complete solution. For example, you may be providing the same output that will be processed by multiple consumers that use different encodings or representations. In other cases, you may be required to allow user-supplied input to contain control information, such as limited HTML tags that support formatting in a wiki or bulletin board. When this type of requirement must be met, use an extremely strict allow list to limit which control sequences can be used. Verify that the resulting syntactic structure is what you expect. Use your normal encoding methods for the remainder of the input.

Use input validation as a defense-in-depth measure to reduce the likelihood of output encoding errors (see CWE-20).

When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.</solution>
	<reference>http://projects.webappsec.org/Improper-Output-Handling</reference>
	<reference/>
</vuln_item_wasc_22>

<vuln_items>wasc_23</vuln_items>
<vuln_item_wasc_23>
	<alert>XML Injection</alert>
	<desc>XML Injection is an attack technique used to manipulate or compromise the logic of an XML application or service. The injection of unintended XML content and/or structures into an XML message can alter the intend logic of the application. Further, XML injection can cause the insertion of malicious content into the resulting message/document.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-Injection</reference>
	<reference/>
</vuln_item_wasc_23>

<vuln_items>wasc_24</vuln_items>
<vuln_item_wasc_24>
	<alert>HTTP Request Splitting</alert>
	<desc>HTTP Request Splitting is an attack that enables forcing the browser to send arbitrary HTTP requests, inflicting XSS and poisoning the browser's cache. The essence of the attack is the ability of the attacker, once the victim (browser) is forced to load the attacker's malicious HTML page, to manipulate one of the browser's functions to send 2 HTTP requests instead of one HTTP request. Two such mechanisms have been exploited to date: the XmlHttpRequest object (XHR for short) and the HTTP digest authentication mechanism. For this attack to work, the browser must use a forward HTTP proxy (not all of them "support" this attack), or the attack must be carried out against a host located on the same IP (from the browser's perspective) with the attacker's machine.</desc>
	<solution>Avoid using CRLF as a special sequence.

Appropriately filter or quote CRLF sequences in user-controlled input.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/93.html</reference>
</vuln_item_wasc_24>

<vuln_items>wasc_25</vuln_items>
<vuln_item_wasc_25>
	<alert>HTTP Response Splitting</alert>
	<desc>In the HTTP Response Splitting attack, there are always 3 parties (at least) involved:
    * Web server, which has a security hole enabling HTTP Response Splitting
    * Target - an entity that interacts with the web server perhaps on behalf of the attacker. Typically this is a cache server forward/reverse proxy), or a browser (possibly with a browser cache).
    * Attacker - initiates the attack

The essence of HTTP Response Splitting is the attacker's ability to send a single HTTP request that forces the web server to form an output stream, which is then interpreted by the target as two HTTP responses instead of one response, in the normal case. The first response may be partially controlled by the attacker, but this is less important. What is material is that the attacker completely controls the form of the second response from the HTTP status line to the last byte of the HTTP response body. Once this is possible, the attacker realizes the attack by sending two requests through the target. The first one invokes two responses from the web server, and the second request would typically be to some "innocent" resource on the web server. However, the second request would be matched, by the target, to the second HTTP response, which is fully controlled by the attacker. The attacker, therefore, tricks the target into believing that a particular resource on the web server (designated by the second request) is the server's HTTP response (server content), while it is in fact some data, which is forged by the attacker through the web server - this is the second response.

HTTP Response Splitting attacks take place where the server script embeds user data in HTTP response headers. This typically happens when the script embeds user data in the redirection URL of a redirection response (HTTP status code 3xx), or when the script embeds user data in a cookie value or name when the response sets a cookie.</desc>
	<solution>Construct HTTP headers very carefully, avoiding the use of non-validated input data.</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/113.html</reference>
</vuln_item_wasc_25>

<vuln_items>wasc_26</vuln_items>
<vuln_item_wasc_26>
	<alert>HTTP Request Smuggling</alert>
	<desc>HTTP Request Smuggling is an attack technique that abuses the discrepancy in parsing of non RFC compliant HTTP requests between two HTTP devices (typically a front-end proxy or HTTP-enabled firewall and a back-end web server) to smuggle a request to the second device "through" the first device. This technique enables the attacker to send one set of requests to the second device while the first device sees a different set of requests. In turn, this facilitates several possible exploitations, such as partial cache poisoning, bypassing firewall protection and XSS.</desc>
	<solution>Use a web server that employs a strict HTTP parsing procedure, such as Apache (See paper in reference).

Use only SSL communication.

Terminate the client session after each request.

Turn all pages to non-cacheable.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Smuggling</reference>
	<reference>http://cwe.mitre.org/data/definitions/444.html</reference>
</vuln_item_wasc_26>

<vuln_items>wasc_27</vuln_items>
<vuln_item_wasc_27>
	<alert>HTTP Response Smuggling</alert>
	<desc>HTTP response smuggling is a technique to "smuggle" 2 HTTP responses from a server to a client, through an intermediary HTTP device that expects (or allows) a single response from the server.

One use for this technique is to enhance the basic HTTP response splitting technique in order to evade anti- HTTP response splitting measures. In this case, the intermediary is the anti-HTTP response splitting mechanism between the web server and the proxy server (or web browser). Another use case is to spoof responses received by the browser. In this case a malicious web site serves the browser a page that the browser will interpret as originating from a different (target) domain. HTTP response smuggling can be used to achieve this when the browser uses a proxy server to access both sites.

HTTP response smuggling makes use of HTTP request smuggling -like techniques to exploit the discrepancies between what an anti- HTTP Response Splitting mechanism (or a proxy server) would consider to be the HTTP response stream, and the response stream as parsed by a proxy server (or a browser). So, while an anti- HTTP response splitting mechanism may consider a particular response stream harmless (single HTTP response), a proxy/browser may still parse it as two HTTP responses, and hence be susceptible to all the outcomes of the original HTTP response splitting technique (in the first use case) or be susceptible to page spoofing (in the second case). For example, some anti- HTTP response splitting mechanisms in use by some application engines forbid the application from inserting a header containing CR+LF to the response. Yet an attacker can force the application to insert a header containing CRs, thereby circumventing the defense mechanism. Some proxy servers may still treat CR (only) as a header (and response) separator, and as such the combination of web server and proxy server will still be vulnerable to an attack that may poison the proxy's cache.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Smuggling</reference>
	<reference/>
</vuln_item_wasc_27>

<vuln_items>wasc_28</vuln_items>
<vuln_item_wasc_28>
	<alert>Null Byte Injection</alert>
	<desc>Null Byte Injection is an active exploitation technique used to bypass sanity checking filters in web infrastructure by adding URL-encoded null byte characters (i.e. %00, or 0x00 in hex) to the user-supplied data. This injection process can alter the intended logic of the application and allow malicious adversary to get unauthorized access to the system files.

Most web applications today are developed using higher-level languages such as, PHP, ASP, Perl, and Java. However, these web applications at some point require processing of high-level code at system level and this process is usually accomplished by using ‘C/C++’ functions. The diverse nature of these dependent technologies has resulted in an attack class called ‘Null Byte Injection’ or ‘Null Byte Poisoning’ attack. In C/C++, a null byte represents the string termination point or delimiter character which means to stop processing the string immediately. Bytes following the delimiter will be ignored. If the string loses its null character, the length of a string becomes unknown until memory pointer happens to meet next zero byte. This unintended ramification can cause unusual behavior and introduce vulnerabilities within the system or application scope. In similar terms, several higher-level languages treat the ‘null byte’ as a placeholder for the string length as it has no special meaning in their context. Due to this difference in interpretation, null bytes can easily be injected to manipulate the application behavior.

URLs are limited to a set of US-ASCII characters ranging from 0x20 to 0x7E (hex) or 32 to 126 (decimal). However, the aforementioned range uses several characters that are not permitted because they have special meaning within HTTP protocol context. For this reason, the URL encoding scheme was introduced to include special characters within URL using the extended ASCII character representation. In terms of “null byte”, this is represented as %00 in hexadecimal. The scope of a null byte attack starts where web applications interact with active ‘C’ routines and external APIs from the underlying OS. Thus, allowing an attacker to manipulate web resources by reading or writing files based on the application's user privileges.</desc>
	<solution>Developers should anticipate that null characters or null bytes will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and white lists to ensure only valid, expected and appropriate input is processed by the system.

Предположим, что весь ввод злонамерен.  Use a standard input validation mechanism to validate all input for length, type, syntax, and business rules before accepting the data to be displayed or stored. Use an "accept known good" validation strategy.

Use and specify a strong output encoding (such as ISO 8859-1 or UTF 8).

Do not rely exclusively on deny list validation to detect malicious input or to encode output. There are too many variants to encode a character; you're likely to miss some variants.

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not decode the same input twice. Such errors could be used to bypass allow list schemes by introducing dangerous inputs after they have been checked.</solution>
	<reference>http://projects.webappsec.org/Null-Byte-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/158.html</reference>
</vuln_item_wasc_28>

<vuln_items>wasc_29</vuln_items>
<vuln_item_wasc_29>
	<alert> LDAP  Внедрение</alert>
	<desc>LDAP Injection is an attack technique used to exploit web sites that construct LDAP statements from user-supplied input.

Lightweight Directory Access Protocol (LDAP) is an open-standard protocol for both querying and manipulating X.500 directory services. The LDAP protocol runs over Internet transport protocols, such as TCP. Web applications may use user-supplied input to create custom LDAP statements for dynamic web page requests.

When a web application fails to properly sanitize user-supplied input, it is possible for an attacker to alter the construction of an LDAP statement. When an attacker is able to modify an LDAP statement, the process will run with the same permissions as the component that executed the command. (e.g. Database server, Web application server, Web server, etc.). This can cause serious security problems where the permissions grant the rights to query, modify or remove anything inside the LDAP tree. The same advanced exploitation techniques available in SQL Injection can also be similarly applied in LDAP Injection.</desc>
	<solution>Предположим, что весь ввод злонамерен.  Use an appropriate combination of black lists and white lists to neutralize LDAP syntax from user-controlled input.</solution>
	<reference>http://projects.webappsec.org/LDAP-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/90.html</reference>
</vuln_item_wasc_29>

<vuln_items>wasc_30</vuln_items>
<vuln_item_wasc_30>
	<alert>Mail Command Injection</alert>
	<desc>Mail Command Injection is an attack technique used to exploit mail servers and webmail applications that construct IMAP/SMTP statements from user-supplied input that is not properly sanitized. Depending on the type of statement taken advantage by the attacker, we meet two types of injections: IMAP and SMTP Injection. An IMAP/SMTP Injection may make it possible to access a mail server which you previously had no access to before-hand. In some cases, these internal systems do not have the same level of infrastructure security hardening applied to them as most front-end web servers. Hence, attackers may find that the mail server yields better results in terms of exploitation. On the other hand, this technique allows to evade possible restrictions that could exist at application level (CAPTCHA, maximum number of requests, etc.).</desc>
	<solution>Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, request headers as well as content, URL components, e-mail, files, databases, and any external systems that provide data to the application. Perform input validation at well-defined interfaces.

Предположим, что весь ввод злонамерен.  Use an "accept known good" input validation strategy (i.e., use an allow list). Отклоняйте любой ввод, который не строго соответствует спецификациям, или преобразуйте его во что-то, что соответствует.  Use a deny list to reject any unexpected inputs and detect potential attacks.

Do not rely exclusively on deny list validation to detect malicious input or to encode output. There are too many ways to encode the same character, so you're likely to miss some variants.

Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not inadvertently decode the same input twice . Such errors could be used to bypass allow list schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.

Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.

When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.

When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.</solution>
	<reference>http://projects.webappsec.org/Mail-Command-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/88.html</reference>
</vuln_item_wasc_30>

<vuln_items>wasc_31</vuln_items>
<vuln_item_wasc_31>
	<alert>OS Commanding</alert>
	<desc>OS Commanding is an attack technique used for unauthorized execution of operating system commands.

OS Commanding is the direct result of mixing trusted code and untrusted data. This attack is possible when an application accepts untrusted input to build operating system commands in an insecure manner involving improper data sanitization, and/or improper calling of external programs. In OS Commanding, executed commands by an attacker will run with the same privileges of the component that executed the command, (e.g. database server, web application server, web server, wrapper, application). Since the commands are executed under the privileges of the executing component an attacker can leverage this to gain access or damage parts that are otherwise unreachable (e.g. the operating system directories and files).</desc>
	<solution>If at all possible, use library calls rather than external processes to recreate the desired functionality.

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. Это может эффективно ограничить, к каким файлам можно получить доступ в конкретном каталоге или какие команды могут выполняться вашим программным обеспечением. 

Примеры уровня ОС включают chroot jail Unix, AppArmor и SELinux.  В общем, управляемый код может обеспечить некоторую защиту.  Например, java.io.FilePermission в Java SecurityManager позволяет вам указывать ограничения на файловые операции. 
Это может быть невыполнимым решением, и оно только ограничивает влияние на операционную систему; остальная часть вашего приложения все еще может быть скомпрометирована. 

For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the command locally in the session's state instead of sending it out to the client in a hidden form field.

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.

For example, consider using the ESAPI Encoding control or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.

If you need to use dynamically-generated query strings or commands in spite of the risk, properly quote arguments and escape any special characters within those arguments. Самый консервативный подход - экранировать или фильтровать все символы, которые не проходят чрезвычайно строгий список разрешений (например, все, что не является буквенно-цифровым или пробельным).  Если некоторые специальные символы все еще необходимы, например, пробел, заключите каждый аргумент в кавычки после этапа экранирования / фильтрации.  Be careful of argument injection.

If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.

Если возможно, используйте структурированные механизмы, которые автоматически обеспечивают разделение данных и кода.  Эти механизмы могут обеспечивать соответствующее цитирование, кодирование и проверку автоматически, вместо того, чтобы полагаться на разработчика, предоставляющего эту возможность в каждой точке, где генерируются выходные данные. 

Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.

Предположим, что весь ввод злонамерен.  Используйте стратегию проверки входных данных «принять заведомо исправные», т. е. Используйте разрешенный список допустимых входных данных, которые строго соответствуют спецификациям.  Отклоняйте любой ввод, который не строго соответствует спецификациям, или преобразуйте его во что-то, что соответствует.  Не полагайтесь исключительно на поиск вредоносных или искаженных входных данных (т. е. Не полагайтесь на список запрещенных).  Однако списки запрета могут быть полезны для обнаружения потенциальных атак или определения того, какие входные данные настолько искажены, что их следует сразу отклонить. 

При выполнении проверки ввода учитывайте все потенциально важные свойства, включая длину, тип ввода, полный диапазон допустимых значений, отсутствующие или дополнительные вводы, синтаксис, согласованность между связанными полями и соответствие бизнес-правилам.  В качестве примера логики бизнес-правила «лодка» может быть синтаксически допустимой, потому что она содержит только буквенно-цифровые символы, но недействительна, если вы ожидаете такие цвета, как «красный» или «синий». 

When constructing OS command strings, use stringent allow lists that limit the character set based on the expected value of the parameter in the request. Это косвенно ограничит масштаб атаки, но этот метод менее важен, чем правильное кодирование вывода и экранирование. 

Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. Это потому, что он эффективно ограничивает то, что будет отображаться на выходе.  Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like ";" and ">" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.

Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.</solution>
	<reference>http://projects.webappsec.org/OS-Commanding</reference>
	<reference>http://cwe.mitre.org/data/definitions/78.html</reference>
</vuln_item_wasc_31>

<vuln_items>wasc_32</vuln_items>
<vuln_item_wasc_32>
	<alert>Routing Detour</alert>
	<desc>The WS-Routing Protocol (WS-Routing) is a protocol for exchanging SOAP messages from an initial message sender to an ultimate receiver, typically via a set of intermediaries. The WS-Routing protocol is implemented as a SOAP extension, and is embedded in the SOAP Header. WS-Routing is often used to provide a way to direct XML traffic through complex environments and transactions by allowing interim way stations in the XML path to assign routing instructions to an XML document.

Routing Detours are a type of "Man in the Middle" attack where Intermediaries can be injected or "hijacked" to route sensitive messages to an outside location. Routing information (either in the HTTP header or in WS-Routing header) can be modified en route and traces of the routing can be removed from the header and message such that the receiving application none the wiser that a routing detour has occurred. The header and the insertion of header objects is often less protected than the message; this is due to the fact that the header is used as a catch all for metadata about the transaction such as authentication, routing, formatting, schema, canonicalization, namespaces, etc. Also, many processes may be involved in adding to/processing the header of an XML document. In many implementations the routing info can come from an external web service (using WS-Referral for example) that provides the specific routing for the transaction.

WS-Addressing is a newer standard published by the W3C to provide routing functionality to SOAP messages. One of the key differences between WS-Routing and WS-Addressing is that WS-Addressing only provides the next location in the route. While little research has been done into the susceptibility of WS-Addressing to Routing Detour Attack, at least one paper (see reference #6 below) suggests that WS-Addressing is vulnerable to Routing Detour as well.</desc>
	<solution>Always fully authenticate both ends of any communications channel.

Adhere to the principle of complete mediation.

A certificate binds an identity to a cryptographic key to authenticate a communicating party. Often, the certificate takes the encrypted form of the hash of the identity of the subject, the public key, and information such as time of issue or expiration using the issuer's private key. The certificate can be validated by deciphering the certificate with the issuer's public key. See also X.509 certificate signature chains and the PGP certification structure.</solution>
	<reference>http://projects.webappsec.org/Routing-Detour</reference>
	<reference>http://cwe.mitre.org/data/definitions/300.html</reference>
</vuln_item_wasc_32>

<vuln_items>wasc_33</vuln_items>
<vuln_item_wasc_33>
	<alert>Обход Пути </alert>
	<desc>The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. An attacker may manipulate a URL in such a way that the web site will execute or reveal the contents of arbitrary files anywhere on the web server. Any device that exposes an HTTP-based interface is potentially vulnerable to Path Traversal.

Most web sites restrict user access to a specific portion of the file-system, typically called the "web document root" or "CGI root" directory. These directories contain the files intended for user access and the executable necessary to drive web application functionality. To access files or execute commands anywhere on the file-system, Path Traversal attacks will utilize the ability of special-characters sequences.

The most basic Path Traversal attack uses the "../" special-character sequence to alter the resource location requested in the URL. Although most popular web servers will prevent this technique from escaping the web document root, alternate encodings of the "../" sequence may help bypass the security filters. These method variations include valid and invalid Unicode-encoding ("..%u2216" or "..%c0%af") of the forward slash character, backslash characters ("..\") on Windows-based servers, URL encoded characters "%2e%2e%2f"), and double URL encoding ("..%255c") of the backslash character.

Even if the web server properly restricts Path Traversal attempts in the URL path, a web application itself may still be vulnerable due to improper handling of user-supplied input. This is a common problem of web applications that use template mechanisms or load static text from files. In variations of the attack, the original URL parameter value is substituted with the file name of one of the web application's dynamic scripts. Consequently, the results can reveal source code because the file is interpreted as text instead of an executable script. These techniques often employ additional special characters such as the dot (".") to reveal the listing of the current working directory, or "%00" NULL characters in order to bypass rudimentary file extension checks.</desc>
	<solution>Предположим, что весь ввод злонамерен.  Используйте стратегию проверки входных данных «принять заведомо исправные», т. е. Используйте разрешенный список допустимых входных данных, которые строго соответствуют спецификациям.  Отклоняйте любой ввод, который не строго соответствует спецификациям, или преобразуйте его во что-то, что соответствует.  Не полагайтесь исключительно на поиск вредоносных или искаженных входных данных (т. е. Не полагайтесь на список запрещенных).  Однако списки запрета могут быть полезны для обнаружения потенциальных атак или определения того, какие входные данные настолько искажены, что их следует сразу отклонить. 

При выполнении проверки ввода учитывайте все потенциально важные свойства, включая длину, тип ввода, полный диапазон допустимых значений, отсутствующие или дополнительные вводы, синтаксис, согласованность между связанными полями и соответствие бизнес-правилам.  В качестве примера логики бизнес-правила «лодка» может быть синтаксически допустимой, потому что она содержит только буквенно-цифровые символы, но недействительна, если вы ожидаете такие цвета, как «красный» или «синий». 

Для имен файлов используйте строгие списки разрешений, которые ограничивают используемый набор символов.  If feasible, only allow a single "." character in the filename to avoid weaknesses, and exclude directory separators such as "/". Use an allow list of allowable file extensions.

Warning: if you attempt to cleanse your data, then do so that the end result is not in the form that can be dangerous. A sanitizing mechanism can remove characters such as '.' and ';' which may be required for some exploits. An attacker can try to fool the sanitizing mechanism into "cleaning" data into a dangerous form. Suppose the attacker injects a '.' inside a filename (e.g. "sensi.tiveFile") and the sanitizing mechanism removes the character resulting in the valid filename, "sensitiveFile". If the input data are now assumed to be safe, then the file may be compromised. 

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not decode the same input twice. Such errors could be used to bypass allow list schemes by introducing dangerous inputs after they have been checked.

Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes ".." sequences and symbolic links.

Запустите свой код, используя самые низкие привилегии, необходимые для выполнения необходимых задач.  Если возможно, создайте изолированные учетные записи с ограниченными правами, которые используются только для одной задачи.  Таким образом, успешная атака не предоставит злоумышленнику немедленный доступ к остальному программному обеспечению или его среде.  Например, приложениям баз данных редко требуется запускать от имени администратора базы данных, особенно в повседневных операциях. 

When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. Это может эффективно ограничить, к каким файлам можно получить доступ в конкретном каталоге или какие команды могут выполняться вашим программным обеспечением. 

Примеры уровня ОС включают chroot jail Unix, AppArmor и SELinux.  В общем, управляемый код может обеспечить некоторую защиту.  Например, java.io.FilePermission в Java SecurityManager позволяет вам указывать ограничения на файловые операции. 

Это может быть невыполнимым решением, и оно только ограничивает влияние на операционную систему; остальная часть вашего приложения все еще может быть скомпрометирована. 
</solution>
	<reference>http://projects.webappsec.org/Path-Traversal</reference>
	<reference>http://cwe.mitre.org/data/definitions/22.html</reference>
</vuln_item_wasc_33>

<vuln_items>wasc_34</vuln_items>
<vuln_item_wasc_34>
	<alert>Predictable Resource Location</alert>
	<desc>Predictable Resource Location is an attack technique used to uncover hidden web site content and functionality. By making educated guesses via brute forcing an attacker can guess file and directory names not intended for public viewing. Brute forcing filenames is easy because files/paths often have common naming convention and reside in standard locations. These can include temporary files, backup files, logs, administrative site sections, configuration files, demo applications, and sample files. These files may disclose sensitive information about the website, web application internals, database information, passwords, machine names, file paths to other sensitive areas, etc...

This will not only assist with identifying site surface which may lead to additional site vulnerabilities, but also may disclose valuable information to an attacker about the environment or its users. Predictable Resource Location is also known as Forced Browsing, Forceful Browsing, File Enumeration, and Directory Enumeration.</desc>
	<solution>Apply appropriate access control authorizations for each access to all restricted URLs, scripts or files.

Consider using MVC based frameworks such as Struts.</solution>
	<reference>http://projects.webappsec.org/Predictable-Resource-Location</reference>
	<reference>http://cwe.mitre.org/data/definitions/425.html</reference>
</vuln_item_wasc_34>

<vuln_items>wasc_35</vuln_items>
<vuln_item_wasc_35>
	<alert>SOAP Array Abuse</alert>
	<desc>XML SOAP arrays are a common target for malicious abuse. SOAP arrays are defined as having a type of "SOAP-ENC:Array" or a type derived there from. SOAP arrays have one or more dimensions (rank) whose members are distinguished by ordinal position. An array value is represented as a series of elements reflecting the array, with members appearing in ascending ordinal sequence. For multi-dimensional arrays the dimension on the right side varies most rapidly. Each member element is named as an independent element. A web-service that expects an array can be the target of a XML DoS attack by forcing the SOAP server to build a huge array in the machine's memory, thus inflicting a DoS condition on the machine due to the memory pre-allocation.</desc>
	<solution> Perform adequate input validation against any value that influences the amount of memory that is allocated. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary.

Run your program using system-provided resource limits for memory. This might still cause the program to crash or exit, but the impact to the rest of the system will be minimized.</solution>
	<reference>http://projects.webappsec.org/SOAP-Array-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/789.html</reference>
</vuln_item_wasc_35>

<vuln_items>wasc_36</vuln_items>
<vuln_item_wasc_36>
	<alert>SSI Injection</alert>
	<desc>SSI Injection (Server-side Include) is a server-side exploit technique that allows an attacker to send code into a web application, which will later be executed locally by the web server. SSI Injection exploits a web application's failure to sanitize user-supplied data before they are inserted into a server-side interpreted HTML file.

Before serving an HTML web page, a web server may parse and execute Server-side Include statements before providing it to the client. In some cases (e.g. message boards, guest books, or content management systems), a web application will insert user-supplied data into the source of a web page.

If an attacker submits a Server-side Include statement, he may have the ability to execute arbitrary operating system commands, or include a restricted file's contents the next time the page is served. This is performed at the permission level of the web server user.</desc>
	<solution>Disable SSI execution on pages that do not require it. For pages requiring SSI ensure that you perform the following checks
- Only enable the SSI directives that are needed for this page and disable all others.
- HTML entity encode user supplied data before passing it to a page with SSI execution permissions.
- Use SUExec to have the page execute as the owner of the file instead of the web server user.</solution>
	<reference>http://projects.webappsec.org/SSI-Injection</reference>
	<reference/>
</vuln_item_wasc_36>

<vuln_items>wasc_37</vuln_items>
<vuln_item_wasc_37>
	<alert>Фиксация сеанса </alert>
	<desc>Session Fixation is an attack technique that forces a user's session ID to an explicit value. Depending on the functionality of the target web site, a number of techniques can be utilized to "fix" the session ID value. These techniques range from Cross-site Scripting exploits to peppering the web site with previously made HTTP requests. After a user's session ID has been fixed, the attacker will wait for that user to login. Once the user does so, the attacker uses the predefined session ID value to assume the same online identity.

Generally speaking there are two types of session management systems when it comes to ID values. The first type is "permissive" systems that allow web browsers to specify any ID. The second type is "strict" systems that only accept server-side-generated values. With permissive systems, arbitrary session IDs are maintained without contact with the web site. Strict systems require the attacker to maintain the "trap-session", with periodic web site contact, preventing inactivity timeouts.

Without active protection against Session Fixation, the attack can be mounted against any web site that uses sessions to identify authenticated users. Web sites using sessions IDs are normally cookie-based, but URLs and hidden form fields are used as well. Unfortunately, cookie-based sessions are the easiest to attack. Most of the currently identified attack methods are aimed toward the fixation of cookies.

In contrast to stealing a users' session IDs after they have logged into a web site, Session Fixation provides a much wider window of opportunity. The active part of the attack takes place before a user logs in.</desc>
	<solution>Invalidate any existing session identifiers prior to authorizing a new user session

For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.</solution>
	<reference>http://projects.webappsec.org/Session-Fixation</reference>
	<reference>http://cwe.mitre.org/data/definitions/384.html</reference>
</vuln_item_wasc_37>

<vuln_items>wasc_38</vuln_items>
<vuln_item_wasc_38>
	<alert>URL Redirector Abuse</alert>
	<desc>URL redirectors represent common functionality employed by web sites to forward an incoming request to an alternate resource. This can be done for a variety of reasons and is often done to allow resources to be moved within the directory structure and to avoid breaking functionality for users that request the resource at its previous location. URL redirectors may also be used to implement load balancing, leveraging abbreviated URLs or recording outgoing links. It is this last implementation which is often used in phishing attacks as described in the example below. URL redirectors do not necessarily represent a direct security vulnerability but can be abused by attackers trying to social engineer victims into believing that they are navigating to a site other than the true destination.</desc>
	<solution>Предположим, что весь ввод злонамерен.  Используйте стратегию проверки входных данных «принять заведомо исправные», т. е. Используйте разрешенный список допустимых входных данных, которые строго соответствуют спецификациям.  Отклоняйте любой ввод, который не строго соответствует спецификациям, или преобразуйте его во что-то, что соответствует.  Не полагайтесь исключительно на поиск вредоносных или искаженных входных данных (т. е. Не полагайтесь на список запрещенных).  Однако списки запрета могут быть полезны для обнаружения потенциальных атак или определения того, какие входные данные настолько искажены, что их следует сразу отклонить. 

При выполнении проверки ввода учитывайте все потенциально важные свойства, включая длину, тип ввода, полный диапазон допустимых значений, отсутствующие или дополнительные вводы, синтаксис, согласованность между связанными полями и соответствие бизнес-правилам.  В качестве примера логики бизнес-правила «лодка» может быть синтаксически допустимой, потому что она содержит только буквенно-цифровые символы, но недействительна, если вы ожидаете такие цвета, как «красный» или «синий». 

Use an allow list of approved URLs or domains to be used for redirection.

Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving your site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems when generating the disclaimer page.

When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

For example, ID 1 could map to "/login.asp" and ID 2 could map to "http://www.example.com/". Такие функции, как ESAPI AccessReferenceMap, предоставляют эту возможность. 

Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Помните, что такие входные данные могут быть получены косвенно через вызовы API. 

Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.</solution>
	<reference>http://projects.webappsec.org/URL-Redirector-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/601.html</reference>
</vuln_item_wasc_38>

<vuln_items>wasc_39</vuln_items>
<vuln_item_wasc_39>
	<alert> XPath Инъекция</alert>
	<desc>XPath Injection is an attack technique used to exploit applications that construct XPath (XML Path Language) queries from user-supplied input to query or navigate XML documents. It can be used directly by an application to query an XML document, as part of a larger operation such as applying an XSLT transformation to an XML document, or applying an XQuery to an XML document. The syntax of XPath bears some resemblance to an SQL query, and indeed, it is possible to form SQL-like queries on an XML document using XPath.

If an application uses run-time XPath query construction, embedding unsafe user input into the query, it may be possible for the attacker to inject data into the query such that the newly formed query will be parsed in a way differing from the programmer's intention.</desc>
	<solution>Use parameterized XPath queries (e.g. using XQuery). This will help ensure separation between data plane and control plane.

Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XPath queries is safe in that context.</solution>
	<reference>http://projects.webappsec.org/XPath-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/643.html</reference>
</vuln_item_wasc_39>

<vuln_items>wasc_40</vuln_items>
<vuln_item_wasc_40>
	<alert>Insufficient Process Validation</alert>
	<desc>Insufficient Process Validation occurs when a web application fails to prevent an attacker from circumventing the intended flow or business logic of the application. When seen in the real world, insufficient process validation has resulted in ineffective access controls and monetary loss.

There are two main types of processes that require validation: flow control and business logic.

"Flow control" refers to multi-step processes that require each step to be performed in a specific order by the user. When an attacker performs the step incorrectly or out of order, the access controls may be bypassed and an application integrity error may occur. Examples of multi-step processes include wire transfer, password recovery, purchase checkout, and account sign-up.

"Business logic" refers to the context in which a process will execute as governed by the business requirements. Exploiting a business logic weakness requires knowledge of the business; if no knowledge is needed to exploit it, then most likely it isn't a business logic flaw. Due to this, typical security measures such as scans and code review will not find this class of weakness. One approach to testing is offered by OWASP in their Testing Guide.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient-Process-Validation</reference>
	<reference/>
</vuln_item_wasc_40>

<vuln_items>wasc_41</vuln_items>
<vuln_item_wasc_41>
	<alert>XML Attribute Blowup</alert>
	<desc>XML Attribute Blowup is a denial of service attack against XML parsers. The attacker provides a malicious XML document, which vulnerable XML parsers process in a very inefficient manner, leading to excessive CPU load. The essence of the attack is to include many attributes in the same XML node. Vulnerable XML parsers manage the attributes in an inefficient manner (e.g. in a data container for which insertion of a new attribute has O(n) runtime), resulting in a non-linear (in this example, quadratic, i.e. O(n2)) overall runtime, leading to a denial of service condition via CPU exhaustion.</desc>
	<solution>Design throttling mechanisms into the system architecture. Лучшая защита - это ограничить количество ресурсов, которые неавторизованный пользователь может использовать.  Надежная модель аутентификации и контроля доступа в первую очередь поможет предотвратить подобные атаки.  Приложение для входа в систему должно быть максимально защищено от DoS-атак.  Ограничение доступа к базе данных, возможно, путем кэширования наборов результатов, может помочь минимизировать затрачиваемые ресурсы.  Чтобы еще больше ограничить вероятность DoS-атаки, рассмотрите возможность отслеживания скорости запросов, полученных от пользователей, и блокировки запросов, которые превышают определенный порог скорости. 

Mitigation of resource exhaustion attacks requires that the target system either:
 * recognizes the attack and denies that user further access for a given amount of time, or
 * uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed. 

Первое из этих решений само по себе является проблемой, поскольку может позволить злоумышленникам предотвратить использование системы конкретным действующим пользователем.  Если злоумышленник выдает себя за действительного пользователя, он может предотвратить доступ пользователя к рассматриваемому серверу. 

Второе решение просто сложно внедрить эффективно - и даже при правильном выполнении оно не дает полного решения.  Это просто заставляет атаку требовать больше ресурсов со стороны злоумышленника. 

Убедитесь, что протоколы имеют определенные ограничения масштаба. 

Ensure that all failures in resource allocation place the system into a safe posture.</solution>
	<reference>http://projects.webappsec.org/XML-Attribute-Blowup</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_41>

<vuln_items>wasc_42</vuln_items>
<vuln_item_wasc_42>
	<alert>Abuse of Functionality</alert>
	<desc>Abuse of Functionality is an attack technique that uses a web site's own features and functionality to attack itself or others. Abuse of Functionality can be described as the abuse of an application's intended functionality to perform an undesirable outcome. These attacks have varied results such as consuming resources, circumventing access controls, or leaking information. The potential and level of abuse will vary from web site to web site and application to application. Abuse of functionality attacks are often a combination of other attack types and/or utilize other attack vectors.</desc>
	<solution>Always utilize APIs in the specified manner.</solution>
	<reference>http://projects.webappsec.org/Abuse-of-Functionality</reference>
	<reference>http://cwe.mitre.org/data/definitions/227.html</reference>
</vuln_item_wasc_42>

<vuln_items>wasc_43</vuln_items>
<vuln_item_wasc_43>
	<alert>XML External Entities</alert>
	<desc>This technique takes advantage of a feature of XML to build documents dynamically at the time of processing. An XML message can either provide data explicitly or by pointing to an URI where the data exists. In the attack technique, external entities may replace the entity value with malicious data, alternate referrals or may compromise the security of the data the server/XML application has access to.
	Attackers may also use External Entities to have the web services server download malicious code or content to the server for use in secondary or follow on attacks.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-External-Entities</reference>
	<reference/>
</vuln_item_wasc_43>

<vuln_items>wasc_44</vuln_items>
<vuln_item_wasc_44>
	<alert>XML Entity Expansion</alert>
	<desc>The XML Entity expansion attack, exploits a capability in XML DTDs that allows the creation of custom macros, called entities, that can be used throughout a document. By recursively defining a set of custom entities at the top of a document, an attacker can overwhelm parsers that attempt to completely resolve the entities by forcing them to iterate almost indefinitely on these recursive definitions.

The malicious XML message is used to force recursive entity expansion (or other repeated processing) that completely uses up available server resources.</desc>
	<solution>If possible, prohibit the use of DTDs or use an XML parser that limits the expansion of recursive DTD entities.

Before parsing XML files with associated DTDs, scan for recursive entity declarations and do not continue parsing potentially explosive content.</solution>
	<reference>http://projects.webappsec.org/XML-Entity-Expansion</reference>
	<reference>http://cwe.mitre.org/data/definitions/776.html</reference>
</vuln_item_wasc_44>

<vuln_items>wasc_45</vuln_items>
<vuln_item_wasc_45>
	<alert>Fingerprinting</alert>
	<desc>The most common methodology for attackers is to first footprint the target's web presence and enumerate as much information as possible. With this information, the attacker may develop an accurate attack scenario, which will effectively exploit a vulnerability in the software type/version being utilized by the target host.

Multi-tier fingerprinting is similar to its predecessor, TCP/IP Fingerprinting (with a scanner such as Nmap) except that it is focused on the Application Layer of the OSI model instead of the Transport Layer. The theory behind this fingerprinting is to create an accurate profile of the target's platform, web application software technology, backend database version, configurations and possibly even their network architecture/topology.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Fingerprinting</reference>
	<reference/>
</vuln_item_wasc_45>

<vuln_items>wasc_46</vuln_items>
<vuln_item_wasc_46>
	<alert>XQuery Injection</alert>
	<desc>XQuery Injection is a variant of the classic SQL injection attack against the XML XQuery Language. XQuery Injection uses improperly validated data that is passed to XQuery commands. This inturn will execute commands on behalf of the attacker that the XQuery routines have access to. XQuery injection can be used to enumerate elements on the victim's environment, inject commands to the local host, or execute queries to remote files and data sources. Like SQL injection attacks, the attacker tunnels through the application entry point to target the resource access layer.</desc>
	<solution>Use parameterized queries. This will help ensure separation between data plane and control plane.

Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XQL queries is safe in that context.</solution>
	<reference>http://projects.webappsec.org/XQuery-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/652.html</reference>
</vuln_item_wasc_46>

<vuln_items>wasc_47</vuln_items>
<vuln_item_wasc_47>
	<alert>Insufficient Session Expiration</alert>
	<desc>Insufficient Session Expiration occurs when a Web application permits an attacker to reuse old session credentials or session IDs for authorization. Insufficient Session Expiration increases a Web site's exposure to attacks that steal or reuse user's session identifiers.

Since HTTP is a stateless protocol, Web sites commonly use cookies to store session IDs that uniquely identify a user from request to request. Consequently, each session ID's confidentiality must be maintained in order to prevent multiple users from accessing the same account. A stolen session ID can be used to view another user's account or perform a fraudulent transaction.

Session expiration is comprised of two timeout types: inactivity and absolute. An absolute timeout is defined by the total amount of time a session can be valid without re-authentication and an inactivity timeout is the amount of idle time allowed before the session is invalidated. The lack of proper session expiration may increase the likelihood of success of certain attacks. A long expiration time increases an attacker's chance of successfully guessing a valid session ID. The longer the expiration time, the more concurrent open sessions will exist at any given time. The larger the pool of sessions, the more likely it will be for an attacker to guess one at random. Although a short session inactivity timeout does not help if a token is immediately used, the short timeout helps to insure that the token is harder to capture while it is still valid.

A Web application should invalidate a session after a predefined idle time has passed (a timeout) and provide the user the means to invalidate their own session, i.e. logout; this helps to keep the lifespan of a session ID as short as possible and is necessary in a shared computing environment where more than one person has unrestricted physical access to a computer. The logout function should be prominently visible to the user, explicitly invalidate a user’s session and disallow reuse of the session token.</desc>
	<solution>Set sessions/credentials expiration date.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Session-Expiration</reference>
	<reference>http://cwe.mitre.org/data/definitions/613.html</reference>
</vuln_item_wasc_47>

<vuln_items>wasc_48</vuln_items>
<vuln_item_wasc_48>
	<alert>Insecure Indexing</alert>
	<desc>Insecure Indexing is a threat to the data confidentiality of the web-site. Indexing web-site contents via a process that has access to files which are not supposed to be publicly accessible has the potential of leaking information about the existence of such files, and about their content. In the process of indexing, such information is collected and stored by the indexing process, which can later be retrieved (albeit not trivially) by a determined attacker, typically through a series of queries to the search engine. The attacker does not thwart the security model of the search engine. As such, this attack is subtle and very hard to detect and to foil - it’s not easy to distinguish the attacker’s queries from a legitimate user’s queries.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insecure-Indexing</reference>
	<reference/>
</vuln_item_wasc_48>

<vuln_items>wasc_49</vuln_items>
<vuln_item_wasc_49>
	<alert>Insufficient Password Recovery</alert>
	<desc>Insufficient Password Recovery is when a web site permits an attacker to illegally obtain, change or recover another user's password. Conventional web site authentication methods require users to select and remember a password or passphrase. The user should be the only person that knows the password and it must be remembered precisely. As time passes, a user's ability to remember a password fades. The matter is further complicated when the average user visits 20 sites requiring them to supply a password.  (RSA Survey: http://news.bbc.co.uk/1/hi/technology/3639679.stm) Thus, password recovery is an important part in servicing online users.

Examples of automated password recovery processes include requiring the user to answer a "secret question" defined as part of the user registration process. This question can either be selected from a list of canned questions or supplied by the user. Another mechanism in use is having the user provide a "hint" during registration that will help the user remember his password. Other mechanisms require the user to provide several pieces of personal data such as their social security number, home address, zip code etc. to validate their identity. After the user has proven who they are, the recovery system will display or e-mail them a new password.

A web site is considered to have Insufficient Password Recovery when an attacker is able to foil the recovery mechanism being used. This happens when the information required to validate a user's identity for recovery is either easily guessed or can be circumvented. Password recovery systems may be compromised through the use of brute force attacks, inherent system weaknesses, or easily guessed secret questions.</desc>
	<solution>Make sure that all input supplied by the user to the password recovery mechanism is thoroughly filtered and validated

Do not use standard weak security questions and use several security questions.

Make sure that there is throttling on the number of incorrect answers to a security question. Disable the password recovery functionality after a certain (small) number of incorrect guesses.

Require that the user properly answers the security question prior to resetting their password and sending the new password to the e-mail address of record.

Never allow the user to control what e-mail address the new password will be sent to in the password recovery mechanism.

Assign a new temporary password rather than revealing the original password.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Password-Recovery</reference>
	<reference>http://cwe.mitre.org/data/definitions/640.html</reference>
</vuln_item_wasc_49>

</vulnerabilities>
